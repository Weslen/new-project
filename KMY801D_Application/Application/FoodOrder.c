#include "FoodOrder.h"
#include "stm32f10x.h"

#include "MenuOperate.h"
#include "global_extern_variable.h"
#include "lcd.h"
#include "gprs.h"
#include <string.h>
#include "setting.h"
#include "ShuRuFa.h"
#include "mypure_library.h"
//#include "des.h"
//#include "base64.h"
#include "my_library.h"
#include <stdio.h>
#include "key.h"
#include <stdlib.h>
#include "EepromFileSystem.h"
#include "SelfTest.h"


#include "kmy_Time.h"
#include "kmy_KeyDrv.h"
#include "kmy_EEPROMDrv.h"
#include "kmy_USART2Drv.h"
#include "kmy_GprsDrv.h"
#include "kmy_LEDDrv.h"
#include "kmy_USART1Drv.h"
#include "kmy_PrinterDrv.h"
#include "kmy_BeepDrv.h"
#include "Version.h"


//define AT commands
#define AT_TcpStatus						"AT+QISTAT\r"
#define AT_IPconnect						"AT+QIDNSIP=0\r"
#define AT_DNSconnect						"AT+QIDNSIP=1\r"
#define AT_ATE0								"ATE0\r"
#define AT_SearchingForNetworks				"AT+COPS?\r"
#define AT_SignalStrength					"AT+CSQ\r"
#define AT_ADC								"AT+QADC?\r"
#define AT_GetIMEI							"AT+GSN\r"
#define AT_TcpSetApn						"AT+QIREGAPP=\""
#define AT_TcpHeadOff						"AT+QIHEAD=0\r"
#define AT_TcpConnect						"AT+QIOPEN=\"TCP\",\""
#define AT_TcpSend							"AT+QISEND="
#define AT_TcpClose1						"AT+QICLOSE\r"
#define AT_TcpClose2						"AT+QIDEACT\r"

#define AUTOCHECK_TIMEOUT 6000

#define DISPLAY_MAXORDERID 10

// eeprom M24512 0x00~ 0x10 000
//  eeprom file system base 0x540
// config file approximately 1024*3, so 0x54+1024*3=0x1140
// |0x540~0x2000 eeprom file system |0x2000~0x7000 confirm order|0x7000 ~0x9000 reject order | 0x9000~0x10000 reserve|
// 0x9000 ~0x9037 local setting

#define TOTAL_CONFIRMADDR 0x2000
#define CONFIRMORDER_BASE TOTAL_CONFIRMADDR+1

//#define TOTAL_REJECTADDR  0x7000 //no need separate confirm or reject order so comment it
//#define	REJECTORDER_BASE TOTAL_REJECTADDR+1

#define ORDRER_SIZE 3072-10

//Order limit count #...# #...# #..# order number
#define ORDER_LIMIT 1

char gOrderBuf[3072]={0};
char pBufNonBlock[256]={0};


static char writeto_gOrderBuf=0;

static char SelectOrderIndex=0;
//static char gGPRS_open=0;
static char ReceiveOrderFlag=0;
static char Writting_gOrderBuf=0;
static char connectfail_conunt=0;


static int check_Interval=0;

char LcdBlackLightFlash=0;
char DebugLock=0;

// replace the string c1 to string c2 from the Buff to DesBuff, no more than 10 c1
void my_string_replace2 (char *Buff, char* DesBuff, char* c1,  char* c2)
{
	char *p=NULL,*p1=NULL;
	int len=0;
	char i=0;

	len=strlen(c1);
	p=Buff;
	p1=p;

	for(i=0;i<10;i++)
	{
		p=strstr(p,c1);
		
		if(p==NULL)break;
		
		strncat(DesBuff,p1,p-p1);
		strcat(DesBuff,c2);

		p=p+len;
		p1=p;
	}
	strcat(DesBuff,p1);
}


void kmy_EnableDisableTime3(char OnOFF)
{
	if(OnOFF==0)
	{
		TIM_Cmd(TIM3, DISABLE);
	}
	else
	{
		TIM_Cmd(TIM3, ENABLE);
	}
}

void kmy_GPRSTimeSet(char init_flag)
{
	unsigned char o_hour=0;
	unsigned char o_min=0;
	unsigned char c_hour=0;
	unsigned char c_min=0;
	unsigned char hour=0;
	unsigned char min=0;
	char *p=NULL;
	
	
	p=(char*)GPRSOpenTime;
	p=strstr(p,":");
	if(p==NULL)
	{
		return;
	}
	o_hour=atoi((char*)GPRSOpenTime);
	p++;
	o_min=atoi(p);

	p=(char*)GPRSCloseTime;
	p=strstr(p,":");
	if(p==NULL)
	{
		return;
	}
	
	c_hour=atoi((char*)GPRSCloseTime);
	p++;
	c_min=atoi(p);
	kmy_TimeGetTime(NULL,NULL,NULL,&hour,&min,NULL,NULL);

	if(init_flag==1)
	{
		printf("Current time hour=%d,min=%d\r\n",hour,min);
			
		printf("Open time o_hour=%d,o_min=%d\r\n",o_hour,o_min);
		
		printf("Close time c_hour=%d,c_min=%d\r\n",c_hour,c_min);
	
		
		TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE);
		TIM_Cmd(TIM3, ENABLE);

	}
	
	if((o_hour>24)||(c_hour>24)||(o_min>60)||(c_min>60))return;
	if((o_hour==c_hour)&&(o_min==c_min))
	{
		GPRS_ONOFF=0;
		return;
	}
	
	if(GPRS_ONOFF==1)//when gprs is close
	{
		printf(".");
		if((c_hour>o_hour)||((c_hour==o_hour)&&c_min>=o_min))//open in daytime
		{
			if(((hour>o_hour)&&(hour<c_hour))||((hour==o_hour)&&(min>=o_min))||((hour==c_hour)&&(min<c_min)))
			{
				GPRS_ONOFF=0;
				//printf("Open: GPRS daytime hour=%d,min=%d\r\n",o_hour,o_min);
			}	
		}
		else//open at night
		{
			if((hour>o_hour||hour<c_hour)||((hour==o_hour)&&(min>=o_min))||((hour==c_hour)&&(min>=c_min)))
			{
				GPRS_ONOFF=0;
				//printf("Open: GPRS night hour=%d,min=%d\r\n",c_hour,c_min);
			}	
		}
		
	}
	else//when gprs is open
	{
		if((c_hour>o_hour)||((c_hour==o_hour)&&c_min>=o_min))//open in daytime
		{
			if((hour>c_hour||hour<o_hour)||((hour==c_hour)&&(min>=c_min))||((hour==o_hour)&&(min<o_min)))
			{
				GPRS_ONOFF=1;
				//printf("Close: GPRS daytime hour=%d,min=%d\r\n",c_hour,c_min);
			}
		}
		else//open at night
		{
			if(((hour>c_hour)&&(hour<o_hour))||((hour==o_hour)&&(min>=o_min))||((hour==c_hour)&&(min<c_min)))
			{
				GPRS_ONOFF=1;
				//printf("Close: GPRS night hour=%d,min=%d\r\n",c_hour,c_min);
			}			
		}
	}
	
}



void Reset_gOrderBuf(void)
{
	memset(gOrderBuf,0,sizeof(gOrderBuf));
}
void HttpGET_VersionString(char* destbuff,const char* VersionUrl, const char *RestaurantID, const char *Version,const char *WebServerIp, const char *WebServerPort)
{
	
	char *p=NULL;

	strcpy(destbuff, "GET ");

	p=(char*)VersionUrl;
	if(strstr(p,"http://")!=NULL)
	{
		p=p+strlen("http:// ");
		p=strstr(p,"/");
		if(p!=NULL)strcat(destbuff, p);
	}
	else if(strstr(p,"www.")!=NULL)
	{
		p=strstr(p,"www.");
		p=strstr(p,"/");
		if(p!=NULL)strcat(destbuff, p);
	}
	else
	{
		strcat(destbuff, VersionUrl);
	}
	
	if(strstr(destbuff,"?")==NULL)
	{
		strcat(destbuff, "?");
	}
	strcat(destbuff, "a=");
	strcat(destbuff, RestaurantID);
	strcat(destbuff, "&ver=");
	strcat(destbuff,Version);
	
	strcat(destbuff, " HTTP/1.1");
	strcat(destbuff, "\r\n");
	
	//Host: 192.168.5.1
	strcat(destbuff, "Host: ");
	if(strlen((char*)Domain)>0)// domain priority
	{
		strcat(destbuff, (char*)Domain);
	}
	else
	{
		strcat(destbuff, WebServerIp);
		strcat(destbuff, ":");
		strcat(destbuff, WebServerPort);
	}	
	strcat(destbuff, "\r\n");
	
	//Pragma: no-cache
	strcat(destbuff, "Pragma: no-cache");
	strcat(destbuff, "\r\n");
	
	//Accept: */*
	strcat(destbuff, "Accept: */*");
	strcat(destbuff, "\r\n");
	
	//Proxy-Connection: Keep-Alive
	strcat(destbuff, "Proxy-Connection: Keep-Alive");
	//User-Agent:KMY main_ver6.09
	strcat(destbuff, "\r\nUser-Agent:KMY ");
	p=(char*)VersionString;
	p=strstr(VersionString,".bin");
	if(p!=NULL)
	{
		strncat(destbuff,VersionString,p-VersionString);
	}
	strcat(destbuff, "\r\n");
	strcat(destbuff, "\r\n");

}
void GetHttpGETString(char* destbuff,
					  const char* OrderRequestWebUrl, const char *RestaurantID, const char *UserName, const char *Password, 
					  const char *WebServerIp, const char *WebServerPort)
{
	
	char *p=NULL;
	
	//GET http://192.168.5.1:81/ibacstel/orderrequest.php?a=2&u=demo&p=123456 HTTP/1.1
	strcpy(destbuff, "GET ");

	//GET /ibacstel/orderrequest.php?a=2&u=demo&p=123456 HTTP/1.1
	p=(char*)OrderRequestWebUrl;
	if(strstr(p,"http://")!=NULL)
	{
		p=p+strlen("http:// ");
		p=strstr(p,"/");
		if(p!=NULL)strcat(destbuff, p);
	}
	else if(strstr(p,"www.")!=NULL)
	{
		p=strstr(p,"www.");
		p=strstr(p,"/");
		if(p!=NULL)strcat(destbuff, p);
	}
	else
	{
		strcat(destbuff, OrderRequestWebUrl);
	}
	
	if(strlen(RestaurantID)!=0&&strlen(UserName)!=0&&strlen(Password)!=0)
	{	
		if(strstr(destbuff,"?")==NULL)
		{
			strcat(destbuff, "?");
		}
		strcat(destbuff, "a=");
		strcat(destbuff, RestaurantID);
		strcat(destbuff, "&u=");
		strcat(destbuff, UserName);
		strcat(destbuff, "&p=");
		strcat(destbuff, Password);
	}
	
	strcat(destbuff, " HTTP/1.1");
	strcat(destbuff, "\r\n");
	
	//Host: 192.168.5.1
	strcat(destbuff, "Host: ");
	if(strlen((char*)Domain)>0)// domain priority
	{
		strcat(destbuff, (char*)Domain);
	}
	else
	{
		strcat(destbuff, WebServerIp);
	}

	strcat(destbuff, "\r\n");
	
	//Pragma: no-cache
	strcat(destbuff, "Pragma: no-cache");
	strcat(destbuff, "\r\n");
	
	//Accept: */*
	strcat(destbuff, "Accept: */*");
	strcat(destbuff, "\r\n");
	
	//Proxy-Connection: Keep-Alive
	strcat(destbuff, "Proxy-Connection: Keep-Alive");
	//User-Agent:KMY main_ver6.09
	strcat(destbuff, "\r\nUser-Agent:KMY ");
	p=(char*)VersionString;
	p=strstr(VersionString,".bin");
	if(p!=NULL)
	{
		strncat(destbuff,VersionString,p-VersionString);
	}
	strcat(destbuff, "\r\n");
	strcat(destbuff, "\r\n");
	
}

void GetHttpCallbackString(char* destbuff,
					   const char* OrderCallbackWebUrl, const char *WebServerIp, const char *WebServerPort,
					   const char *RestaurantID, const char *UserName, const char *Password, 
					   const char* OrderNO, const char* Answer, const char* RejectReason, const char* DeliverTime)
{
	char *p=NULL;
	
	//GET http://192.168.5.1:81/ibacstel/orderrequest.php?a=2&o=111914&ak=Accepted&m=ok&dt=19:30&u=demo&p=123456
	strcpy(destbuff, "GET ");
	p=(char*)OrderCallbackWebUrl;
	if(strstr(p,"http://")!=NULL)
	{
		p=p+strlen("http:// ");
		p=strstr(p,"/");
		if(p!=NULL)strcat(destbuff, p);
	}
	else if(strstr(p,"www.")!=NULL)
	{
		p=strstr(p,"www.");
		p=strstr(p,"/");
		if(p!=NULL)strcat(destbuff, p);
	}
	else
	{
		strcat(destbuff, OrderCallbackWebUrl);
	}
	if(strstr(OrderCallbackWebUrl,"?")==NULL)
	{
		strcat(destbuff, "?");
	}
	strcat(destbuff, "a=");
	strcat(destbuff, RestaurantID);
	strcat(destbuff, "&o=");
	strcat(destbuff, OrderNO);
	strcat(destbuff, "&ak=");
	strcat(destbuff, Answer);
	strcat(destbuff, "&m=");
	strcat(destbuff, RejectReason);
	strcat(destbuff, "&dt=");
	strcat(destbuff, DeliverTime);
	strcat(destbuff, "&u=");
	strcat(destbuff, UserName);
	strcat(destbuff, "&p=");
	strcat(destbuff, Password);
	strcat(destbuff, " HTTP/1.1");
	strcat(destbuff, "\r\n");
	
	//Host: 192.168.5.1
	strcat(destbuff, "Host: ");
	if(strlen((char*)Domain)>0)// domain priority
	{
		strcat(destbuff, (char*)Domain);
	}
	else
	{
		strcat(destbuff, WebServerIp);
	}

	strcat(destbuff, "\r\n");
	
	//Pragma: no-cache
	strcat(destbuff, "Pragma: no-cache");
	strcat(destbuff, "\r\n");
	
	//Accept: */*
	strcat(destbuff, "Accept: */*");
	strcat(destbuff, "\r\n");
	
	//Proxy-Connection: Keep-Alive
	strcat(destbuff, "Proxy-Connection: Keep-Alive");
	//User-Agent:KMY main_ver6.09
	strcat(destbuff, "\r\nUser-Agent:KMY ");
	p=(char*)VersionString;
	p=strstr(VersionString,".bin");
	if(p!=NULL)
	{
		strncat(destbuff,VersionString,p-VersionString);
	}
	strcat(destbuff, "\r\n");
	strcat(destbuff, "\r\n");
}

//POST http://192.168.5.1:81/ibacstel/printer.php HTTP/1.1
//Host: 192.168.5.1:81
//Pragma: no-cache
//Accept: */*
//Proxy-Connection: Keep-Alive
//Content-Length: 54
//Content-Type: application/x-www-form-urlencoded

//a=2&o=111654&ak=Accepted&m=ok&dt=19:30&u=demo&p=123456

void GetHttpPOSTString(char* destbuff,
					   const char* OrderPostWebUrl, const char *WebServerIp, const char *WebServerPort,
					   const char *RestaurantID, const char *UserName, const char *Password, 
					   const char* OrderNO, const char* Answer, const char* RejectReason, const char* DeliverTime)
{
	char PostFiledDatas[100] = {0};
	char ContentLengthBuf[50] = {0};
	int  ContentLengthBufIndex = 0;
	
	//make post field
	strcpy(PostFiledDatas, "a=");
	strcat(PostFiledDatas, RestaurantID);
	strcat(PostFiledDatas, "&o=");
	strcat(PostFiledDatas, OrderNO);
	strcat(PostFiledDatas, "&ak=");
	strcat(PostFiledDatas, Answer);
	strcat(PostFiledDatas, "&m=");
	strcat(PostFiledDatas, RejectReason);
	strcat(PostFiledDatas, "&dt=");
	strcat(PostFiledDatas, DeliverTime);
	strcat(PostFiledDatas, "&u=");
	strcat(PostFiledDatas, UserName);
	strcat(PostFiledDatas, "&p=");
	strcat(PostFiledDatas, Password);

	//make Content-Length
	strcpy(ContentLengthBuf, "Content-Length: ");
	ContentLengthBufIndex = strlen(ContentLengthBuf);
	sprintf(ContentLengthBuf+ContentLengthBufIndex, "%d", strlen(PostFiledDatas));

	//POST http://192.168.5.1:81/ibacstel/printer.php HTTP/1.1
	strcpy(destbuff, "POST ");
	strcat(destbuff, OrderPostWebUrl);
	strcat(destbuff, " HTTP/1.1");
	strcat(destbuff, "\r\n");
	
	//Host: 192.168.5.1:81
	strcat(destbuff, "Host: ");
	strcat(destbuff, WebServerIp);
	strcat(destbuff, ":");
	strcat(destbuff, WebServerPort);
	strcat(destbuff, "\r\n");
	
	//Pragma: no-cache
	strcat(destbuff, "Pragma: no-cache");
	strcat(destbuff, "\r\n");
	
	//Accept: */*
	strcat(destbuff, "Accept: */*");
	strcat(destbuff, "\r\n");
	
	//Proxy-Connection: Keep-Alive
	strcat(destbuff, "Proxy-Connection: Keep-Alive");
	strcat(destbuff, "\r\n");
	
	//Content-Length: 37
	strcat(destbuff, ContentLengthBuf);
	strcat(destbuff, "\r\n");
	
	//Content-Type: application/x-www-form-urlencoded
	strcat(destbuff, "Content-Type: application/x-www-form-urlencoded");
	strcat(destbuff, "\r\n");

	//a=2&o=111654&ak=Accepted&m=ok&dt=19:30&u=demo&p=123456
	strcat(destbuff, "\r\n");
	strcat(destbuff, PostFiledDatas);
	strcat(destbuff, "\r\n");
	strcat(destbuff, "\r\n");
	
}

int GetCountOfOrders(const char *HttpContents)
{
	char *p1 = NULL;
	char *p2 = NULL;
	int Count = 0;

	//find the 1st "#"
	p1 = strstr(HttpContents, "#");
	if(p1 == NULL)
		return Count;
	
	while(1)
	{
		/* ignore the 1st "#" */
		p1 += 1; 
		
		/* find the 2nd "#" */
		p2 = strstr(p1, "#");
		if(p2 == NULL)
			break;
		/* ignore the 2nd "#" */
		p2 += 1;
		
		if(p2 - p1 > 0)Count++;
				
		
		/* find the 1st "#" */
		p1 = strstr(p2, "#");
		if(p1 == NULL)
			break;
	}
	return Count;
}


char* GetOneOrder(char *OrderString, ORDER_STRUCT *order, char *gOrderFood, char *CustomerComments)
{
	char *p1 = NULL;
	char *p2 = NULL;
	char State = 0;
	int i = 0;
	int pLength = 0;
	int pIndex = 0;//PublicIndex
	int fIndex = 0;//FoodIndex
	char IgnoreFlag = 1;

	int onelineprit=0;//one line can print 32 characters, if one line exactly 32 characters it will auto strcat a "\n"
	unsigned char temp[51]={0};

	typedef struct 
	{
		char CategoryName[50];//specially for Australia pro
		char FoodQuantiy[5];//ItemQuantity
		char FoodName[1024];//ItEMTitle, change 300 to 500, 20130826
		char FoodAmount[10];//ItemPrice
	}FOOD;
	FOOD food={0};

/*step1 --- check if there is a string start with "#" && end with "#" */
	p1 = strstr(OrderString, "#");
	/* ignore the 1st "#" */
	
	if(p1 == NULL )
	{	
		return NULL;
	}	
	p1 += 1; 

	/* check if there is a "#" in the end */
	p2 = strstr(p1, "#");
	/* ignore the 2nd "#" */
	if(p2 == NULL )
	{	
		return NULL;
	}
	p2 += 1; 

	/* get the pLength of datas between the two "#" */
	pLength = p2 - p1;
	if(pLength>3072)return NULL;
	
/*step2 --- Analysis datas */
	for(i=0; i<pLength; )
	{
		switch(State)
		{
		case 0:/* preparetion */
			pIndex = 0;
			State++;
			break;
			
		case 1:/* get RestaurantID, end with "*" */
			if(*p1 != '*')
			{
				order->RestaurantID[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->RestaurantID))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;

		case 2:/* get OrderType, end with "*" */
			if(*p1 != '*')
			{
				order->OrderType[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->OrderType))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;
			
		case 3:/* get OrderNumber, end with "*" */
			if(*p1 != '*')
			{
				order->OrderNumber[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->OrderNumber))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;
			case 4:/* get OrderFood[fIndex].CategoryName,specially for the Australia projectsa */
				if(*p1 != ',')
				{
					//order->OrderFood[fIndex].CategoryName[pIndex] = *p1;
					//if(pIndex+1 < sizeof(order->OrderFood[fIndex].CategoryName))pIndex++;
					food.CategoryName[pIndex] = *p1;
					if(pIndex+1 <sizeof( food.CategoryName))pIndex++;
					p1++;i++;
				}
				else
				{	
					memset(temp,0,sizeof(temp));
					my_string_replace2(food.CategoryName,(char*)temp,"%%","\n");
					if(strcmp((char*)temp," ")!=0)// if category not empty, strcat a \n
					{
						strcat(gOrderFood,(char*)temp);
						strcat(gOrderFood,"\n");		
					}	
					memset(food.CategoryName,0,sizeof(food.CategoryName));
					
					p1++;i++;
					pIndex = 0;
					State++;
				}
				break;
			
			
/* ----------------------------------------------------------------------------------------- */
		case 5:/* get OrderFood[fIndex].FoodQuantiy, start with "0~9" && end with "," */
			
			if(IgnoreFlag)
			{
				if(*p1 >= '0' && *p1 <= '9')
				{
					IgnoreFlag = 0; 									
				}
				else
				{
					p1++;i++;
				}
			}
			else
			{
				if(*p1 != ',')
				{
					//order->OrderFood[fIndex].FoodQuantiy[pIndex] = *p1;
					//if(pIndex+1 < sizeof(order->OrderFood[fIndex].FoodQuantiy))pIndex++;
					food.FoodQuantiy[pIndex] = *p1;
					if(pIndex+1 < sizeof(food.FoodQuantiy))pIndex++;

					p1++;i++;
				}
				else
				{					
					strcat(gOrderFood,food.FoodQuantiy);
					strcat(gOrderFood," X ");
					onelineprit=strlen(food.FoodQuantiy)+strlen(" X ");
					memset(food.FoodQuantiy,0,sizeof(food.FoodQuantiy));
					
					p1++;i++;
					pIndex = 0;
					State++;
				}
			}
			break;
			
		case 6:/* get OrderFood[fIndex].FoodName, end with "," */
			if(*p1 != ',')
			{
				//order->OrderFood[fIndex].FoodName[pIndex] = *p1;
				//if(pIndex+1 < sizeof(order->OrderFood[fIndex].FoodName))pIndex++;
				food.FoodName[pIndex] = *p1;
				if(pIndex+1 < sizeof(food.FoodName))pIndex++;

				p1++;i++;
			}
			else
			{
				my_string_replace((unsigned char*)food.FoodName,'%','\n');
				strcat(gOrderFood,food.FoodName);	
				strcat(gOrderFood,"  ");
				onelineprit +=strlen(food.FoodName)+strlen("  ");				
				memset(food.FoodName,0,sizeof(food.FoodName));
				
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;

		case 7:/* get OrderFood[fIndex].FoodAmount, end with ";" */
			if(*p1 == '*')
			{
				strcat(gOrderFood,food.FoodAmount);
				onelineprit +=strlen(food.FoodAmount);
				//if(onelineprit%32!=0)strcat(gOrderFood,"\n");
				strcat(gOrderFood,"\n");
				onelineprit=0;
				memset(food.FoodAmount,0,sizeof(food.FoodAmount));
					
				p1++;i++;
				pIndex = 0;
				/* will jump to case 7:, End get OrderFood[] */
				State++;
			}
			else
			{
				if(*p1 != ';')
				{
					//order->OrderFood[fIndex].FoodAmount[pIndex] = *p1;
					//if(pIndex+1 < sizeof(order->OrderFood[fIndex].FoodAmount))pIndex++;
					food.FoodAmount[pIndex] = *p1;
					if(pIndex+1 < sizeof(food.FoodAmount))pIndex++;

					p1++;i++;
				}
				else
				{
					strcat(gOrderFood,food.FoodAmount); 	
					onelineprit +=strlen(food.FoodAmount);
					//if(onelineprit%32!=0)
					strcat(gOrderFood,"\n");
					onelineprit=0;
					memset(food.FoodAmount,0,sizeof(food.FoodAmount));
					
					p1++;i++;
					pIndex = 0;
					/* will jump to case 4:, Continue to get OrderFood[] */
					State = 4;
					/* need Ignore some chars before OrderFood[fIndex].FoodQuantiy */
					IgnoreFlag = 1;
					
					fIndex++;
				}
			}
			break;
/* ----------------------------------------------------------------------------------------- */

		case 8:/* get DeliveryCharge, end with ";" */
			if(*p1 != ';')
			{
				order->DeliveryCharge[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->DeliveryCharge))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;

		case 9:/* get CC_HandelingFees, end with ";" */
			if(*p1 != ';')
			{
				order->CC_HandelingFees[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->CC_HandelingFees))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;

		case 10:/* get Discount, end with ";" */
			if(*p1 != ';')
			{
				order->Discount[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->Discount))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;

		case 11:/* get Total, end with ";" */
			if(*p1 != ';')
			{
				order->Total[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->Total))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;

				/* need Ignore some chars before CustomerType */
				IgnoreFlag = 1;
			}
			break;

		case 12:/* get CustomerType, end with ";" */
			if(IgnoreFlag)
			{
				if(*p1 >= '0' && *p1 <= '9')
				{
					IgnoreFlag = 0; 									
				}
				else
				{
					p1++;i++;
				}
			}
			else
			{
				if(*p1 != ';')
				{
					order->CustomerType[pIndex] = *p1;
					if(pIndex+1 < sizeof(order->CustomerType))pIndex++;

					p1++;i++;
				}
				else
				{
					p1++;i++;
					pIndex = 0;
					State++;
				}
			}
			break;

		case 13:/* get CustomerName, end with ";" */
			if(*p1 != ';')
			{
				order->CustomerName[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->CustomerName))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;

		case 14:/* get CustomerAddress, end with ";" */
			if(*p1 != ';')
			{
				order->CustomerAddress[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->CustomerAddress))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;

		case 15:/* get RequestTime, end with ";" */
			if(*p1 != ';')
			{
				order->RequestTime[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->RequestTime))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;

		case 16:/* get PreviousNumberOfOrders, end with ";" */
			if(*p1 != ';')
			{
				order->PreviousNumberOfOrders[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->PreviousNumberOfOrders))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;

		case 17:/* get PaymentStatus, end with ";" */
			if(*p1 != ';')
			{
				order->PaymentStatus[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->PaymentStatus))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;
			
		case 18:/* get PaymentCardNo, end with ";" */
			if(*p1 != ';')
			{
				order->PaymentCardNo[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->PaymentCardNo))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;
			}
			break;

		case 19:/* get CustomerPhone, end with ";" */
			if(*p1 != ';')
			{
				order->CustomerPhone[pIndex] = *p1;
				if(pIndex+1 < sizeof(order->CustomerPhone))pIndex++;

				p1++;i++;
			}
			else
			{
				p1++;i++;
				pIndex = 0;
				State++;

				/* need Ignore some chars before CustomerComments */
				IgnoreFlag = 1;
			}
			break;

		case 20:/* get CustomerComments, end with "#" */
			if(IgnoreFlag)
			{
				if(*p1 == '*')
				{
					IgnoreFlag = 0; 									
					p1++;i++;
				}
				else
				{
					p1++;i++;
				}
			}
			else
			{
				if(*p1 != '#')
				{
					//order->CustomerComments[pIndex] = *p1;
					CustomerComments[pIndex] = *p1;
					if(pIndex+1 < 200)
					{
						pIndex++;
					}

					p1++;i++;
				}
				else
				{
					p1++;i++;
					pIndex = 0;
					State++;
				}
			}
			break;

		default:
			break;
			
		}

	}

/*	printf("%s\r\n", order->RestaurantID);
	printf("%s\r\n", order->OrderType);
	printf("%s\r\n", order->OrderNumber);
	
	printf("%s\r\n", gOrderFood);
	
	printf("%s\r\n", order->DeliveryCharge);
	printf("%s\r\n", order->CC_HandelingFees);
	//printf("%s\r\n", order->Discount);
	printf("%s\r\n", order->Total);
	printf("%s\r\n", order->CustomerType);
	printf("%s\r\n", order->CustomerName);
	printf("%s\r\n", order->CustomerAddress);
	printf("%s\r\n", order->RequestTime);
	printf("%s\r\n", order->PreviousNumberOfOrders);
	printf("%s\r\n", order->PaymentStatus);
	printf("%s\r\n", order->PaymentCardNo);
	printf("%s\r\n", order->CustomerPhone);
	printf("%s\r\n", CustomerComments);
*/
	return p2;	
}



char AcceptRejectOrders(void)
{
	unsigned char retval;
	clear_lcd();
	DrawTitle_to_row_Language2 (2, "Accept this order?", "Accept this order?");
	text_out_to_row_x_Language2 (4, 6,"Cancel", "Cancel");
	text_out_to_row_x_Language2 (4, 100,"OK", "OK");
	
	while(1)
	{
		retval = kmy_GetKeyValue();
		
		if (retval == KEY_NONE) continue;
		if (beepKG[0] == '1')
		{
			BeepNormal();
		}

		switch (retval)
		{
			case KEY_Enter:
			case KEY_ReturnPrevious:
			case KEY_ReturnInitInterface:
				
				return retval;
			default: break;
		}

	}
}


char SeperateIpAndPort(char *IPandPort, char *IP, char *Port)
{
	int i=0;
	char *p;
	char tmp[7]={0};
	
	if(strlen(IPandPort)<9)return 1;
	p=IPandPort;
	i=atoi(p);
	if(i>255)return 1;
	sprintf(tmp,"%d",i);
//	printf("tmp=%s\r\n",tmp);
	strcpy(IP,tmp);
	strcat(IP,".");

	p=strstr(p,".");
	p++;
	i=atoi(p);
	if(i>255)return 1;
	sprintf(tmp,"%d",i);
//	printf("tmp=%s\r\n",tmp);
	strcat(IP,tmp);
	strcat(IP,".");

	p=strstr(p,".");
	p++;
	i=atoi(p);
	if(i>255)return 1;
	sprintf(tmp,"%d",i);
//	printf("tmp=%s\r\n",tmp);
	strcat(IP,tmp);
	strcat(IP,".");

	p=strstr(p,".");
	p++;
	i=atoi(p);
	if(i>255)return 1;
	sprintf(tmp,"%d",i);
//	printf("tmp=%s\r\n",tmp);
	strcat(IP,tmp);

	p=strstr(p,",");
	p++;

	IPandPort=p;
	for (i = 0; i < 5; i++)
	{
		if (*IPandPort >= '0' && *IPandPort <= '9')
		{
			Port[i] = *IPandPort;
			IPandPort++;
		}
	}
	return 0;//IP correct
}

char GetSelectItemOfMenus_SpeedAcceptKey (char (*Menus)[MENU_COL], char MaxItems,char *SelectItemIndex) //0 <= MenuVar.CurMenuIndex[0] <MaxItems
{
#define _4RowOneScr 5
#define KEY_FLASHINTERFACE 0x55
	char tmp[4]={0};
	char tmpbuff[20]={0};
	char TempKey = KEY_NONE;

	typedef struct
	{
		char CurMenuIndex;
		char OldHighLightRow;
		char CurHighLightRow;
		char MenuScrollCount;
		char MenuLayerCnt;
		char FlashFlag;
	} MENUVAR;

	MENUVAR MenuVar = {0, 0, 0, 0, 0, 0x01};

	MenuVar.CurHighLightRow = 0;

	printf("-------------------\r\n");
//	printf("%s\r\n",Menus[0]);
	
	if (MenuVar.CurMenuIndex >= _4RowOneScr)
	{
		MenuVar.MenuScrollCount = (MenuVar.CurMenuIndex + 1) - _4RowOneScr;
		MenuVar.CurHighLightRow = _4RowOneScr - 1;
		MenuVar.OldHighLightRow = _4RowOneScr - 1;
	}
	else
	{
		MenuVar.CurHighLightRow = MenuVar.CurMenuIndex;
		MenuVar.OldHighLightRow = MenuVar.CurMenuIndex;
	}

	PostKey (KEY_FLASHINTERFACE);

	while (1)
	{
		TempKey = kmy_GetKeyValue();

		if (TempKey == KEY_NONE) continue;

		switch (TempKey)
		{
			case KEY1:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				SelectItemIndex[0] =1;
				return KEY_Enter;
			case KEY2:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				SelectItemIndex[0] =2;
				return KEY_Enter;
			case KEY3:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				SelectItemIndex[0] =3;
				return KEY_Enter;
			case KEY4:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				SelectItemIndex[0] =4;
				return KEY_Enter;
			case KEY5:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				SelectItemIndex[0] =5;
				return KEY_Enter;
			case KEY6:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				SelectItemIndex[0] =6;
				return KEY_Enter;
			case KEY7:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				SelectItemIndex[0] =7;
				return KEY_Enter;
			case KEY8:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				SelectItemIndex[0] =8;
				return KEY_Enter;
			case KEY9:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				SelectItemIndex[0] =9;
				return KEY_Enter;
			case KEY_UP:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				if ( (MenuVar.CurHighLightRow == 0) && (MenuVar.MenuScrollCount - 1 >= 0) ) //
				{
					MenuVar.MenuScrollCount --;
					MenuVar.FlashFlag |= 0x01;//0x01---需要刷新整个界面
				}

				if (MenuVar.CurMenuIndex - 1 >= 0)
				{
					if (MenuVar.CurHighLightRow - 1 >= 0) MenuVar.CurHighLightRow --;

					MenuVar.CurMenuIndex --;
					MenuVar.FlashFlag |= 0x02;//0x02---需要刷新高亮行
				}
				PostKey (KEY_FLASHINTERFACE);
				break;

			case KEY_DOWN:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				if ( (MenuVar.CurHighLightRow >= (_4RowOneScr - 1) ) && (MenuVar.MenuScrollCount + 1 <= (MaxItems - _4RowOneScr) ) )
				{
					MenuVar.MenuScrollCount ++;
					MenuVar.FlashFlag |= 0x01;//0x01---需要刷新整个界面
				}

				if (MenuVar.CurMenuIndex + 1 < MaxItems)
				{
					if (MenuVar.CurHighLightRow + 1 < _4RowOneScr) MenuVar.CurHighLightRow ++;

					MenuVar.CurMenuIndex ++;
					MenuVar.FlashFlag |= 0x02;//0x02---需要刷新高亮行
				}
				PostKey (KEY_FLASHINTERFACE);
				break;

			case KEY_Enter://enter
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				SelectItemIndex[0] = MenuVar.CurMenuIndex;
				return KEY_Enter;
			case KEY_DEL:			
				SelectItemIndex[0] = MenuVar.CurMenuIndex;
				return KEY_DEL;
			case KEY_R2://exit
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				return KEY_ReturnInitInterface;

			case KEY_L1://return
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				return KEY_ReturnPrevious;

			case KEY_FLASHINTERFACE:
				
				if ( (MenuVar.FlashFlag & 0x01) == 0x01) //0x01---需要刷新整个界面
				{
					kmy_LcdClear();

					if (MaxItems >= 1)
					{
						memset(tmp,0,sizeof(tmp));						
						memset(tmpbuff,0,sizeof(tmpbuff));
						sprintf(tmp,"%d.",MenuVar.MenuScrollCount+1);
						strcpy(tmpbuff,tmp);
						strcat(tmpbuff,Menus[0 + MenuVar.MenuScrollCount]);
						text_out_to_row(0,(unsigned char *)tmpbuff);
					//	text_out_to_row (0, (const unsigned char *)Menus[0 + MenuVar.MenuScrollCount]);
					}
//					printf("MaxItems=%d,MenuScrollCount=%d,%s\r\n",MaxItems,MenuVar.MenuScrollCount,*Menus[0]);

					if (MaxItems >= 2)
					{
						memset(tmp,0,sizeof(tmp));						
						memset(tmpbuff,0,sizeof(tmpbuff));
						sprintf(tmp,"%d.",MenuVar.MenuScrollCount+2);
						strcpy(tmpbuff,tmp);
						strcat(tmpbuff,Menus[1 + MenuVar.MenuScrollCount]);
						text_out_to_row(1,(unsigned char *)tmpbuff);
						//text_out_to_row (1, (const unsigned char *)Menus[1 + MenuVar.MenuScrollCount]);
					}
//					printf("MaxItems=%d,MenuScrollCount=%d,%s\r\n",MaxItems,MenuVar.MenuScrollCount,*Menus[1]);
					if (MaxItems >= 3)
					{
						memset(tmp,0,sizeof(tmp));						
						memset(tmpbuff,0,sizeof(tmpbuff));
						sprintf(tmp,"%d.",MenuVar.MenuScrollCount+3);
						strcpy(tmpbuff,tmp);
						strcat(tmpbuff,Menus[2 + MenuVar.MenuScrollCount]);
						text_out_to_row(2,(unsigned char *)tmpbuff);
						//text_out_to_row (2, (const unsigned char *)Menus[2 + MenuVar.MenuScrollCount]);
					}

					if (MaxItems >= 4)
					{
						memset(tmp,0,sizeof(tmp));						
						memset(tmpbuff,0,sizeof(tmpbuff));
						sprintf(tmp,"%d.",MenuVar.MenuScrollCount+4);
						strcpy(tmpbuff,tmp);
						strcat(tmpbuff,Menus[3 + MenuVar.MenuScrollCount]);
						text_out_to_row(3,(unsigned char *)tmpbuff);
						//text_out_to_row (3, (const unsigned char *)Menus[3 + MenuVar.MenuScrollCount]);
					}

					if (MaxItems >= 5)
					{
						memset(tmp,0,sizeof(tmp));						
						memset(tmpbuff,0,sizeof(tmpbuff));
						sprintf(tmp,"%d.",MenuVar.MenuScrollCount+5);
						strcpy(tmpbuff,tmp);
						strcat(tmpbuff,Menus[4 + MenuVar.MenuScrollCount]);
						text_out_to_row(4,(unsigned char *)tmpbuff);
						//text_out_to_row (4, (const unsigned char *)Menus[4 + MenuVar.MenuScrollCount]);
					}

					DispHighLightRow (MenuVar.CurHighLightRow + 0); //高亮
					MenuVar.FlashFlag &= ~0x01;
				}

				if ( (MenuVar.OldHighLightRow != MenuVar.CurHighLightRow) && ( (MenuVar.FlashFlag & 0x02) == 0x02) ) //0x02---需要刷新高亮行
				{
					DispHighLightRow (MenuVar.OldHighLightRow + 0); //取消高亮
					DispHighLightRow (MenuVar.CurHighLightRow + 0); //高亮
					MenuVar.OldHighLightRow = MenuVar.CurHighLightRow;
					MenuVar.FlashFlag &= ~0x02;
				}

				break;

			default:
				
				break;
		}

	}
}

char GetSelectItemOfMenus (char (*Menus)[MENU_COL], char MaxItems,char *SelectItemIndex) //0 <= MenuVar.CurMenuIndex[0] <MaxItems
{
#define _4RowOneScr 5
#define KEY_FLASHINTERFACE 0x55
	char tmp[4]={0};
	char tmpbuff[20]={0};
	char TempKey = KEY_NONE;

	typedef struct
	{
		char CurMenuIndex;
		char OldHighLightRow;
		char CurHighLightRow;
		char MenuScrollCount;
		char MenuLayerCnt;
		char FlashFlag;
	} MENUVAR;

	MENUVAR MenuVar = {0, 0, 0, 0, 0, 0x01};

	MenuVar.CurHighLightRow = 0;

	printf("-------------------\r\n");
//	printf("%s\r\n",Menus[0]);
	
	if (MenuVar.CurMenuIndex >= _4RowOneScr)
	{
		MenuVar.MenuScrollCount = (MenuVar.CurMenuIndex + 1) - _4RowOneScr;
		MenuVar.CurHighLightRow = MenuVar.CurMenuIndex-MenuVar.MenuScrollCount;
		MenuVar.OldHighLightRow = MenuVar.CurMenuIndex-MenuVar.MenuScrollCount;
	}
	else
	{
		MenuVar.CurHighLightRow = MenuVar.CurMenuIndex-MenuVar.MenuScrollCount;
		MenuVar.OldHighLightRow = MenuVar.CurMenuIndex-MenuVar.MenuScrollCount;
	}

	PostKey (KEY_FLASHINTERFACE);

	while (1)
	{
		TempKey = kmy_GetKeyValue();

		if (TempKey == KEY_NONE) continue;

		switch (TempKey)
		{
			case KEY_UP:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				if ( (MenuVar.CurHighLightRow == 0) && (MenuVar.MenuScrollCount - 1 >= 0) ) //
				{
					MenuVar.MenuScrollCount --;
					MenuVar.FlashFlag |= 0x01;//0x01---需要刷新整个界面
				}

				if (MenuVar.CurMenuIndex - 1 >= 0)
				{
					if (MenuVar.CurHighLightRow - 1 >= 0) MenuVar.CurHighLightRow --;

					MenuVar.CurMenuIndex --;
					MenuVar.FlashFlag |= 0x02;//0x02---需要刷新高亮行
				}
				PostKey (KEY_FLASHINTERFACE);
				break;

			case KEY_DOWN:
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				if ( (MenuVar.CurHighLightRow >= (_4RowOneScr - 1) ) && (MenuVar.MenuScrollCount + 1 <= (MaxItems - _4RowOneScr) ) )
				{
					MenuVar.MenuScrollCount ++;
					MenuVar.FlashFlag |= 0x01;//0x01---需要刷新整个界面
				}

				if (MenuVar.CurMenuIndex + 1 < MaxItems)
				{
					if (MenuVar.CurHighLightRow + 1 < _4RowOneScr) MenuVar.CurHighLightRow ++;

					MenuVar.CurMenuIndex ++;
					MenuVar.FlashFlag |= 0x02;//0x02---需要刷新高亮行
				}
				PostKey (KEY_FLASHINTERFACE);
				break;

			case KEY_Enter://enter
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				SelectItemIndex[0] = MenuVar.CurMenuIndex;
				return KEY_Enter;
			case KEY_DEL:			
				SelectItemIndex[0] = MenuVar.CurMenuIndex;
				return KEY_DEL;
			case KEY_R2://exit
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				return KEY_ReturnInitInterface;

			case KEY_L1://return
				if (beepKG[0] == '1')
				{
					BeepNormal();
				}
				
				return KEY_ReturnPrevious;

			case KEY_FLASHINTERFACE:
				
				if ( (MenuVar.FlashFlag & 0x01) == 0x01) //0x01---需要刷新整个界面
				{
					kmy_LcdClear();

					if (MaxItems >= 1)
					{
						memset(tmp,0,sizeof(tmp));						
						memset(tmpbuff,0,sizeof(tmpbuff));
						sprintf(tmp,"%d.",MenuVar.MenuScrollCount+1);
						strcpy(tmpbuff,tmp);
						strcat(tmpbuff,Menus[0 + MenuVar.MenuScrollCount]);
						text_out_to_row(0,(unsigned char *)tmpbuff);
					//	text_out_to_row (0, (const unsigned char *)Menus[0 + MenuVar.MenuScrollCount]);
					}
//					printf("MaxItems=%d,MenuScrollCount=%d,%s\r\n",MaxItems,MenuVar.MenuScrollCount,*Menus[0]);

					if (MaxItems >= 2)
					{
						memset(tmp,0,sizeof(tmp));						
						memset(tmpbuff,0,sizeof(tmpbuff));
						sprintf(tmp,"%d.",MenuVar.MenuScrollCount+2);
						strcpy(tmpbuff,tmp);
						strcat(tmpbuff,Menus[1 + MenuVar.MenuScrollCount]);
						text_out_to_row(1,(unsigned char *)tmpbuff);
						//text_out_to_row (1, (const unsigned char *)Menus[1 + MenuVar.MenuScrollCount]);
					}
//					printf("MaxItems=%d,MenuScrollCount=%d,%s\r\n",MaxItems,MenuVar.MenuScrollCount,*Menus[1]);
					if (MaxItems >= 3)
					{
						memset(tmp,0,sizeof(tmp));						
						memset(tmpbuff,0,sizeof(tmpbuff));
						sprintf(tmp,"%d.",MenuVar.MenuScrollCount+3);
						strcpy(tmpbuff,tmp);
						strcat(tmpbuff,Menus[2 + MenuVar.MenuScrollCount]);
						text_out_to_row(2,(unsigned char *)tmpbuff);
						//text_out_to_row (2, (const unsigned char *)Menus[2 + MenuVar.MenuScrollCount]);
					}

					if (MaxItems >= 4)
					{
						memset(tmp,0,sizeof(tmp));						
						memset(tmpbuff,0,sizeof(tmpbuff));
						sprintf(tmp,"%d.",MenuVar.MenuScrollCount+4);
						strcpy(tmpbuff,tmp);
						strcat(tmpbuff,Menus[3 + MenuVar.MenuScrollCount]);
						text_out_to_row(3,(unsigned char *)tmpbuff);
						//text_out_to_row (3, (const unsigned char *)Menus[3 + MenuVar.MenuScrollCount]);
					}

					if (MaxItems >= 5)
					{
						memset(tmp,0,sizeof(tmp));						
						memset(tmpbuff,0,sizeof(tmpbuff));
						sprintf(tmp,"%d.",MenuVar.MenuScrollCount+5);
						strcpy(tmpbuff,tmp);
						strcat(tmpbuff,Menus[4 + MenuVar.MenuScrollCount]);
						text_out_to_row(4,(unsigned char *)tmpbuff);
						//text_out_to_row (4, (const unsigned char *)Menus[4 + MenuVar.MenuScrollCount]);
					}

					DispHighLightRow (MenuVar.CurHighLightRow + 0); //高亮
					MenuVar.FlashFlag &= ~0x01;
				}

				if ( (MenuVar.OldHighLightRow != MenuVar.CurHighLightRow) && ( (MenuVar.FlashFlag & 0x02) == 0x02) ) //0x02---需要刷新高亮行
				{
					DispHighLightRow (MenuVar.OldHighLightRow + 0); //取消高亮
					DispHighLightRow (MenuVar.CurHighLightRow + 0); //高亮
					MenuVar.OldHighLightRow = MenuVar.CurHighLightRow;
					MenuVar.FlashFlag &= ~0x02;
				}

				break;

			default:
				
				break;
		}

	}
}

const unsigned char printlogo[]=
{
/*------------------------------------------------------------------------------
;  源文件 / 文字 : E:\Develop Task\second\KMY801D FoodOrder_Australia\澳大利亚资料要求\image001(11-21-09-49-23).BMP字模
;  宽×高（像素）: 382×125
------------------------------------------------------------------------------*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0xC0,0xC0,0xE0,0xE0,0xF0,0xF0,0xF0,0xF0,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,
0xF8,0xF8,0xF8,0xF0,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,
0xFF,0xFF,0x7F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xE0,0xF0,0xF0,0xF8,
0xF8,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xF8,0xF8,0xF0,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xF0,0xF0,0xF8,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,
0xF8,0xF0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0xE0,0xF8,0xFC,0xFF,0xFF,0xFF,0x3F,0x1F,0x07,0x03,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0x4F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0xC0,0xC0,0xC0,0xC0,0xE0,0xC0,0xC0,0xC0,
0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0xF0,0xF0,0xFC,
0xFC,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0x70,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xF0,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xE0,0xE0,
0xF0,0xF0,0xF0,0xF0,0xF8,0xF8,0xF8,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,
0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xF8,0xF8,0xF8,0xF0,0xF0,0xF0,0xE0,0xE0,0xC0,
0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0xE0,0xF0,
0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFD,0xFF,
0xFF,0xFF,0x7F,0x0F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0x3F,0x03,0x00,0x80,0xC0,0xF0,0xF8,0xFC,0xFF,0xFF,0xFF,0x7F,
0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xF8,
0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x7F,0x7F,0x7F,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFE,0xF8,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x80,0xE0,0xF0,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00,0x00,0x00,0x00,0x80,0xE0,0xF0,
0xF0,0xF8,0xF8,0xF8,0xF8,0xF8,0xF0,0xC0,0x00,0x00,0x00,0x80,0xFC,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0x7F,0x3F,0x1F,0x0F,0x07,0x07,0x03,0x03,0x03,0x01,0x01,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x8F,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFE,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xF0,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFE,0xF8,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xF0,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xC3,0xF0,0xFC,0xFF,0xFF,0x7F,0x1F,0x0F,0x03,0x03,0x01,0x00,0x00,0x00,0x00,
0xC0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0x1F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0xE0,0xF0,0xF8,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0x7F,0x0F,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0xF0,
0xFC,0xFF,0xFF,0x3F,0xDF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0x3F,0x07,0x00,0x00,0x00,0xC0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x0F,0x01,0x00,0x80,0xE0,0xF8,0xFC,
0xFE,0xFC,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFE,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x03,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x7C,0xFC,0xFE,0xFE,0xFE,0xFE,0xFC,0xFC,
0xFC,0xFC,0xF8,0xF8,0xF8,0xF8,0xFC,0xFE,0xFF,0x7F,0x7F,0x3F,0x1F,0x0F,0x07,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xC0,0xF0,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xDF,0xC3,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xF8,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,
0x1F,0x0F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xF8,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0xF8,0xFC,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x0F,0x03,0x00,
0x00,0x00,0x00,0x80,0x80,0x80,0xC0,0xC0,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x1F,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xF0,0xFC,0xFF,0xFF,0x3F,0x3F,0x0F,0x03,
0xE0,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x0F,
0x01,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,
0x0F,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x1F,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0xFC,0xFC,0xFE,0xFF,0x3F,0x3F,0x0F,0x07,0x01,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0xE0,0xC0,0xC0,
0x80,0x80,0x80,0x80,0x80,0xC0,0xC0,0xC0,0xC1,0xC1,0xC1,0xC3,0xC3,0xC3,0xC3,0xC3,
0x83,0x81,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xF8,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF8,0xE0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xF8,0xFC,0xFC,0xFC,0xFC,0xFE,0xFE,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x1F,
0x1F,0x1F,0x1F,0x1F,0x0F,0x0F,0x0F,0x0F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x0F,0x07,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x07,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x80,0xE0,0xF8,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x03,0x00,0x00,0x00,0x00,0x00,0x7E,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF9,0xF0,0xE0,
0xE0,0xF0,0xF8,0xFE,0xFF,0x7F,0x1F,0x0F,0x03,0x01,0x00,0xC0,0xF8,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0x00,0x00,0x00,0x80,
0x80,0xC0,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0x83,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0xC0,0xE0,0xF8,0xFC,0xFF,0xFF,0xFF,0x7F,0x1F,0x0F,0x03,0x03,0x07,
0x03,0x03,0x03,0x03,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x83,0x87,0xCF,0xCF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x7F,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x80,0xC0,0xE0,0xE0,0xF0,0xF0,0xF8,0xFC,0xFC,0xFC,0xFC,0xFC,0xFE,
0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0xF0,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x0F,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x07,0x1F,0x7F,0xFF,0xFF,0xFF,0xF8,0xF0,0xC0,0x80,0x00,0x00,
0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0x1F,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x80,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xF0,
0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xF1,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x3F,0x3F,0x3F,0x3F,0x1F,0x1F,0x1F,0x0F,0x0F,0x07,
0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x3F,
0x1F,0x0F,0x03,0x1F,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,
0x7F,0x7F,0x3F,0x1F,0x0F,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0x7F,0x3F,0x1F,0x0F,0x07,0x03,0x03,0x03,0x03,0x03,0x07,0x07,0x07,
0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x03,0x03,0x03,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xF0,0xF8,0xFC,0xFE,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x1F,0x0F,0x07,
0x07,0x07,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0x3F,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,
0xF8,0xFC,0xFF,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0x1F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x07,0x0F,0x0F,0x1F,0x3F,0x7F,0xFE,0xFC,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x8F,0x80,0x80,0xC0,0xC0,0xE0,0xE0,0xF0,0xF0,0xF0,0x40,0x00,0x00,0x00,0x00,0xE0,
0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xE2,0x80,0xC0,0xC0,0xE0,0xF0,0xF8,0xFC,0xFF,0xFF,0x7F,0x1F,0x0F,0x03,
0x01,0x00,0x07,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFC,0xFC,0xFC,0xFE,0xFF,0xFF,0xFF,0x7F,0x3F,0x1F,
0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x0F,0x0F,0x1F,0x1F,0x1F,0x1F,
0x1F,0x1F,0x1F,0x1F,0x0F,0x0F,0x07,0x07,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x03,0x01,0x01,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x0F,0x07,0x03,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xE0,0xF0,0xF0,0xF8,0xF8,
0xF8,0xFC,0xFC,0xFC,0xF8,0xFC,0xF8,0xF8,0xF8,0xF0,0xE0,0xE0,0xC0,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x80,0xE0,0xF8,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x0F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,
0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x03,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0xF0,0xFC,0xFF,0xFF,0x3F,0x0F,0x83,
0xF8,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,
0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xFC,0xFE,0xFF,0x7F,
0x3F,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x0F,0x0F,0x0F,0x0F,
0x0F,0x0F,0x07,0x07,0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0x7F,0x3F,0x1F,0x0F,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x03,0x07,0x0F,0x1F,0x1F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
0x3F,0x1F,0x1F,0x0F,0x0F,0x0F,0x07,0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xE0,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xF0,
0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0xC0,0xE0,0xF0,0xF8,0xF8,0x78,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC0,0xF0,0xF8,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x0F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xE0,0xFC,0xFE,0xFF,0xFF,0xFF,0x1F,0x0F,0x07,0x03,0x03,0x01,0x00,
0x00,0x00,0x01,0x01,0x01,0x03,0x07,0x1F,0xFF,0xFF,0xFF,0xFF,0xFE,0xF8,0xE0,0xF8,
0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x3F,0x0F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF0,0xFE,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x03,0x00,0x00,0x00,0x00,0x00,
0xC0,0xE0,0xF0,0xFC,0xFF,0xFF,0x3F,0x0F,0x07,0x03,0x00,0xC0,0xFC,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0xC0,0xC0,
0xE0,0xE0,0xF0,0xF8,0xFE,0xFF,0xFF,0x7F,0x3F,0x1F,0x07,0x03,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x1F,0x0F,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x0F,0x1F,0x1F,
0x3F,0x7F,0x7F,0x7F,0x7F,0x3F,0x3F,0x3F,0x3F,0x1F,0x0F,0x0F,0x07,0x03,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xC0,0x00,
0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0xF8,0xFC,0xFE,0xFE,0x3F,0x1F,0x07,0x87,0xFF,
0xFF,0xFF,0xFF,0x7F,0x0F,0x00,0x00,0xC0,0x70,0x3C,0xCE,0xFF,0xFF,0xFF,0xFF,0x9F,
0xC3,0xE0,0x30,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0x8F,0x80,0xE0,0x70,0x38,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0x00,0x00,
0x00,0x80,0xC0,0xE0,0xF0,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0xF0,0xF8,0xFC,0xFF,0xFF,0x3F,0x1F,
0x0F,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x3F,0x1F,
0x0F,0x0F,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x0F,0x1F,0x3F,0x3F,0x3F,0x3F,0x1F,0x1F,0x1F,0x0F,0x0F,0x0F,0x07,0x03,
0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0xC0,0xE0,0xE0,0xE0,0xF0,0x70,0xF0,0xE0,0xC0,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,
0xF8,0xFC,0x3C,0x0E,0x0E,0xFE,0xFC,0xF0,0x00,0x00,0x00,0x00,0xC0,0x78,0xFE,0xFF,
0xFF,0xFF,0xFF,0xC0,0xF0,0x38,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x38,0x0E,0xC7,
0xFF,0xFF,0xFF,0xFF,0x3F,0x03,0x80,0xC0,0x60,0x20,0x80,0xC0,0xC0,0x80,0x00,0x10,
0x18,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0xC0,0xF0,0x78,0xFE,0xFF,0xFF,0xFF,0xFF,
0xFF,0x70,0x18,0x0E,0x07,0x03,0x78,0xFF,0xFF,0x7F,0x7F,0x3F,0x0F,0x07,0x01,0x00,
0x00,0x1F,0x3F,0x3F,0x1F,0x1F,0x0F,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x7F,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xF0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0xC0,0xF0,0xFC,0xFF,0xFF,0xFF,0xFF,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x7F,0x3F,0x1F,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x3F,0x0F,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x0F,0x1F,0x1F,0x3F,0x3F,0x3F,0x3F,
0x3F,0x3F,0x1F,0x1F,0x0F,0x0F,0x07,0x07,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0xF8,0xFC,0xFF,0xFF,0xFF,0x0F,
0x03,0x00,0x02,0x07,0x0F,0x87,0xC3,0xF0,0xFC,0xFE,0xFF,0xFF,0xFF,0x7F,0x03,0x00,
0x80,0xF8,0xFC,0x7F,0x7F,0x71,0x30,0x3C,0x0E,0x83,0xF0,0xFE,0xFF,0xFF,0x7F,0x1F,
0x07,0x01,0xE0,0xFC,0xFF,0xFF,0x3F,0x1F,0x07,0x01,0x00,0x00,0x3D,0x7F,0x7F,0x7F,
0x3F,0x1F,0x0E,0x07,0x03,0x01,0x04,0x1F,0x1F,0x1F,0x1F,0x0F,0x03,0x00,0x00,0x03,
0x07,0x07,0x07,0x07,0x07,0x03,0x01,0x00,0x00,0x01,0x03,0x03,0x03,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x0F,0x1F,0x7F,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFE,0xF8,0xF8,0xF0,0xE0,0xE0,0xE0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
0xC0,0xC0,0xC0,0xC0,0xE0,0xE0,0xF0,0xF0,0xF8,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,
0x7F,0x1F,0x0F,0x03,0x00,0x00,0x03,0x0F,0x3F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x3F,0x1F,0x0F,0x0F,0x07,0x03,0x01,0x00,0x00,
0x00,0x00,0x00,0x03,0x0F,0x0F,0x0F,0x1F,0x1F,0x1F,0x1F,0x0F,0x0F,0x0F,0x07,0x03,
0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF0,
0xF8,0xF8,0xF8,0x70,0x00,0x03,0x03,0x1F,0x7F,0x7F,0x7F,0xFF,0xFD,0x70,0x70,0x38,
0x38,0x1C,0x0E,0x07,0x01,0x00,0x07,0x1F,0x1F,0x1F,0x1F,0x1F,0x1E,0x0E,0x07,0x03,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,
0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,
0x07,0x0F,0x1F,0x1F,0x3F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0x7F,0x7F,0x3F,0x3F,0x1F,0x0F,0x0F,0x07,0x03,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x03,0x03,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x01,0x01,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

// when print with zoom1 NumPerLine = 32 characters per line;
// when print with zoom2 NumPerLine = 16 characters per line
// this function is use to add carriage while print at the margin of the paper.
void AddCarriage(char *Buff, char NumPerLine)
{
	char *p1 = NULL;
	char *p2 = NULL;
	unsigned char len=0;
	unsigned int length=0;
	unsigned int i;

	length=strlen(Buff);

	p1 = Buff;
	p2 = p1;

	for(i=0;i<length;i++)
	{ 
	    if(*p1 == '\n')
		{
			len = 0;
			p2 = p1;
		}
		else if(*p1 == ' ')
		{
			p2 = p1;
			len++;
		}
		else
		{
			len++;
		}
		       
		if(len==NumPerLine+1 )
		{
			if((*p1 != ' ')&&(*p1 != '\n'))
			{
				*p2='\n';
			}
			len=p1-p2; 
		}
		p1++;
	}
}
void BeepLound (void)
{
	kmy_BeepOn();
	msleep (100);
	kmy_BeepOff();
}

static void kmy_PrinterUseUsart3(void)
{
	GPIO_ResetBits(GPIOB,GPIO_Pin_13);
}

char PrintOrder(ORDER_STRUCT *order, char reprint, char index, char *gOrderFood, char *CustomerComments)
{
	char ret=0;
	char buff[500]={0};
	unsigned char temp[31]={0};
	unsigned int year = 0;
	unsigned char month = 0;
	unsigned char date = 0;
	unsigned char hour = 0;
	unsigned char minite = 0;
	unsigned char second = 0;


	printf("%s\r\n", order->RestaurantID);
	printf("%s\r\n", order->OrderType);
	printf("%s\r\n", order->OrderNumber);
	
	printf("%s\r\n", gOrderFood);
	
	printf("%s\r\n", order->DeliveryCharge);
	printf("%s\r\n", order->CC_HandelingFees);
	printf("%s\r\n", order->Total);
	printf("%s\r\n", order->CustomerType);
	printf("%s\r\n", order->CustomerName);
	printf("%s\r\n", order->CustomerAddress);
	printf("%s\r\n", order->RequestTime);
	printf("%s\r\n", order->PreviousNumberOfOrders);
	printf("%s\r\n", order->PaymentStatus);
	printf("%s\r\n", order->PaymentCardNo);
	printf("%s\r\n", order->CustomerPhone);
	printf("%s\r\n", CustomerComments);
	
	kmy_EnableDisableTime3(0);// timer3 disable
	kmy_TimeGetTime (&year, &month, &date, &hour, &minite, &second, NULL);
	clear_lcd();
	DrawTitle_to_row_Language2 (2, "Printing...", "Printing...");
	

	// print the header EatNow order
	/*kmy_PrinterSetcommand (WidthZoom2, sizeof (WidthZoom2) );
	kmy_PrinterSetcommand (HighZoom1, sizeof (HighZoom1) );
	memset(temp,0,sizeof(temp));
	strcpy((char*)temp,(char*)PrintPageHeader);
	my_string_replace(temp,'%','\n');
	strcat(buff,(char*)temp);
	strcat(buff,"\n");
	ret=kmy_PrinterString((unsigned char*)buff);
	if (ret != Printer_OK) goto PrinterErrorExit;
	*/
	// print date, ordertype and order No.
	kmy_PrinterUseUsart3();
	kmy_PrinterSetcommand (WidthZoom1, sizeof (WidthZoom1) );
	kmy_PrinterSetcommand (HighZoom1, sizeof (HighZoom1) );
	ret=kmy_PrinterBitmap (printlogo, 382, 125, (384 - 382) / 2);
	if (ret != Printer_OK) goto PrinterErrorExit;
	kmy_PrinterSetcommand ("\x10\x05\x05\x0f",4 );// print darker
	
	memset(temp,0,sizeof(temp));
	sprintf((char*)temp,"      %02d-%02d-%04d %02d:%02d:%02d\r\n",date,month,year,hour,minite,second);
	ret=kmy_PrinterString(temp);
	if (ret != Printer_OK) goto PrinterErrorExit;
	memset(buff,0,sizeof(buff));
	kmy_PrinterSetcommand (WidthZoom2, sizeof (WidthZoom2) );
	kmy_PrinterSetcommand (HighZoom2, sizeof (HighZoom2) );
	kmy_PrinterSetcommand("\x1b\x31\x01",3);//Set line spacing
	if(order[index].OrderType[0]=='1')
	{
		strcpy(buff,"Delivery");
	}
	else
	{
		strcpy(buff,"Collection");
	}
	strcat(buff,"\n-------------------\n");
	strcat(buff,"Order No: ");
	strcat(buff,order[index].OrderNumber);
	strcat(buff,"\n-------------------\n");
	AddCarriage(buff,16);
	ret=kmy_PrinterString((unsigned char*)buff);
	if (ret != Printer_OK) goto PrinterErrorExit;
	
	kmy_PrinterSetcommand (WidthZoom1, sizeof (WidthZoom1) );
	kmy_PrinterSetcommand (HighZoom1, sizeof (HighZoom1) );
	
	printf("gOrderFoodlen=%d\r\n",strlen(gOrderFood));
	AddCarriage(gOrderFood,32);
	ret=kmy_PrinterString((unsigned char*)gOrderFood);
	if (ret != Printer_OK) goto PrinterErrorExit;
	memset(buff,0,sizeof(buff));
	
	strcat(buff,"\n------------------------\n");
	strcat(buff,"Delivery Chg: ");
	strcat(buff,order[index].DeliveryCharge);
	strcat(buff,"\nCC+Han fees: ");
	strcat(buff,order[index].CC_HandelingFees);
	strcat(buff,"\n");

	if(strlen(order[index].Discount)>0)
	{
		strcat(buff,"Discounts: ");
		strcat(buff,order[index].Discount);
		strcat(buff,"\n");
	}
	AddCarriage(buff,32);
	ret=kmy_PrinterString((unsigned char*)buff);
	if (ret != Printer_OK) goto PrinterErrorExit;
	
	kmy_PrinterSetcommand (WidthZoom2, sizeof (WidthZoom2) );
	kmy_PrinterSetcommand (HighZoom2, sizeof (HighZoom2) );
	memset(buff,0,sizeof(buff));
	strcat(buff,"Total: ");
	strcat(buff,order[index].Total);
	strcat(buff,"\n---------------\n");
	ret=kmy_PrinterString((unsigned char*)buff);		
	if (ret != Printer_OK) goto PrinterErrorExit;
	
	kmy_PrinterSetcommand (WidthZoom1, sizeof (WidthZoom1) );
	kmy_PrinterSetcommand (HighZoom1, sizeof (HighZoom1) );
	memset(buff,0,sizeof(buff));
	
	strcpy(buff,order[index].CustomerName);
	strcat(buff,"\nCustomer: ");
	if(strstr(order[index].CustomerType,"4"))
	{
		strcat(buff,"Verified");
	}
	else
	{
		strcat(buff,"Not Verified");
	}
	strcat(buff,"\nPrevious orders: ");
	strcat(buff,order[index].PreviousNumberOfOrders);
	strcat(buff,"\nCustomer Phone: ");
	strcat(buff,order[index].CustomerPhone);	
	strcat(buff,"\n");

	strcat(buff,order[index].CustomerAddress);
	AddCarriage(buff,32);
	strcat(buff,"\n------------------------\n");
	ret=kmy_PrinterString((unsigned char*)buff);
	if (ret != Printer_OK) goto PrinterErrorExit;
	
	kmy_PrinterSetcommand (WidthZoom2, sizeof (WidthZoom2) );
	kmy_PrinterSetcommand (HighZoom2, sizeof (HighZoom2) );
	memset(buff,0,sizeof(buff));
	strcpy(buff,"Requested for:\n");
	strcat(buff,order[index].RequestTime);
	strcat(buff,"\n---------------\n");
	if(strstr(order[index].PaymentStatus,"6"))
	{
		strcat(buff,"Order Paid");
	}
	else
	{
		strcat(buff,"Order Not Paid");
	}
	AddCarriage(buff,16);
	strcat(buff,"\n---------------\n");
	ret=kmy_PrinterString((unsigned char*)buff);
	if (ret != Printer_OK) goto PrinterErrorExit;

	kmy_PrinterSetcommand (WidthZoom1, sizeof (WidthZoom1) );
	kmy_PrinterSetcommand (HighZoom1, sizeof (HighZoom1) );
	
	memset(buff,0,sizeof(buff));
	strcpy(buff,"Payment Card: ");
	strcat(buff,order[index].PaymentCardNo);
	
	strcat(buff,"\nComments: ");
	if(strlen(CustomerComments)>0)
	{
		strcat(buff,CustomerComments);
		strcat(buff,"\n");
		AddCarriage(buff,32);
	}
	
	memset(temp,0,sizeof(temp));
	strcpy((char*)temp,(char*)PrintPageFooter);
	my_string_replace(temp,'%','\n');
	strcat(buff,(char*)temp);
	strcat(buff,"\n\n\n\n\n\n\n\n");
	ret=kmy_PrinterString((unsigned char*)buff);
	if (ret != Printer_OK) goto PrinterErrorExit;
	kmy_EnableDisableTime3(1);// timer3 ensable
	return Printer_OK;	
	PrinterErrorExit:
		if (ret == Printer_NoPaper)
		{
			clear_lcd();
			DrawTitle_to_row_Language2 (2, "No paper", "No paper");
			DrawTitle_to_row_Language2 (3, "Please insert it", "Please insert it");

			while(1)
			{			
				BeepLound();
				msleep(100);
				if(kmy_GetKeyValue()!=KEY_NONE)
				{
					kmy_EnableDisableTime3(1);// timer3 ensable
					return Printer_NoPaper;
				}
			}
		}
		else
		{
			//kmy_PrinterInit();
			//clear_lcd();
			//DrawTitle_to_row_Language2 (2, "print error", "print error");
			printf("print error=%d\r\n",ret);
			printf("gorderBuf={\r\n%s\r\n",gOrderBuf);
			NVIC_SystemReset();
		}
		kmy_EnableDisableTime3(1);// timer3 ensable
		return WaitkeyAndAutoExit (10);

}
char DisplayOrder(unsigned char num, ORDER_STRUCT *order, char *index, char *gOrderFood, char *CustomerComments)
{
	char i=0;
	char orderlist[ORDER_LIMIT][MENU_COL]={0};
	char retval=0;
	
	printf("========================\r\n");
	while(1)
	{
		for(i=0;i<num;i++)
		{
			strcpy(orderlist[i],order[i].OrderNumber);
			printf("%s\r\n",orderlist[i]);
		}
		retval=GetSelectItemOfMenus(orderlist,num,index);
		if(retval==KEY_Enter)
		{
			retval=PrintOrder(order,0,*index,gOrderFood,CustomerComments);
			if(retval==Printer_OK)
			{
				return KEY_Enter;
			}
			else
			{
				return KEY_ReturnPrevious;
			}
				
		}
		else
		{
			return retval;	
		}

	}
}
char GetSelectOrderID(char *src, char index, char *des)
{
	int i=0;
	char *p1=NULL,*p=NULL;
	int len=0;
	
	p1=src;
	p1=strstr(p1,"#");
	for(i=1;i<index;i++)
	{
		p1++;
		p1=strstr(p1,"#");
		p1++;
		p1=strstr(p1,"#");
	}
	
	if(p1!=NULL)
	{
		p1++;
		p1=strstr(p1,"*");
		if(p1==NULL)return 1;	
		p1++;
		p1=strstr(p1,"*");
		if(p1==NULL)return 1;	
		p1++;
		p=p1;
		p1=strstr(p1,"*");
		if(p1==NULL)return 1;	
		
		len=p1-p;
		strncpy(des,p,len);
		return 0;	
	}
	return 1;	
}


char DeleteOneOrder(char *buff,char index)
{
	char i;
	char *p;

	int len=0;


	p=buff;
	p=strstr(p,"#");
	for(i=1;i<index;i++)
	{
		printf("into here....\r\n");
		p++;
		p=strstr(p,"#");
		p++;
		p=strstr(p,"#");
	}
	if(p!=NULL)
	{
		buff=p;
		p++;
		p=strstr(p,"#");
		
		if(p!=NULL)
		{
			p++;
			len=p-buff;
		
			while(*p!=0)
			{
				*buff=*p;
				buff++;
				p++;
			}
			p=p-len;
			while(*p!=0)
			{
				*p=0;
				p++;
			}
		}
		else
		{
			while(*buff!=0)
			{
				*buff=0;
				buff++;
			}
		}
		return 0;
	}
	else
	{
		return 1;
	}
	
}
char ReadOutOrders(unsigned short ORDER_BASE, char (*OrdernumBuff)[MENU_COL],unsigned short *AddressList)
{
	unsigned char total=0;
	int i=0;
	int offset=0;
	char temp[21]={0};
	int loop=0;
	unsigned short WriteAddr=0;
	struct
	{
		unsigned int year;
		unsigned char month;
		unsigned char date;
		unsigned char hour;
		unsigned char minite;
		unsigned char second;
	}dt;	

	kmy_EepromReadByte(ORDER_BASE-1,&total);
	
	printf("Read recent orders total=%d\r\n",total);
	
	if(total==0)
	{
		clear_lcd();
		
		DrawTitle_to_row(1,"No Recent Order");

		WaitkeyAndAutoExit(10);
		return 1;
	}
	if (total>2*DISPLAY_MAXORDERID)// if not initial store memory
	{
		clear_lcd();
		DrawTitle_to_row(1,"No Recent Order");
		
		InitOrder();//reset the total number
		
		WaitkeyAndAutoExit(10);
		return 1;
	}
// reverse show the orderID list
	offset =(total-1)%DISPLAY_MAXORDERID;
	if(total<DISPLAY_MAXORDERID)
	{
		loop=total;
	}
	else
	{
		loop=DISPLAY_MAXORDERID;
	}
	for(i=0;i<loop;i++)
	{
		memset(temp,0,sizeof(temp));
		WriteAddr=ORDER_BASE+offset*ORDRER_SIZE;
		AddressList[i]=WriteAddr;//printf("AddressList[%d]=%d\r\n",i,AddressList[i]);
		// read out : orderID + date time
		kmy_EepromReadSequent(WriteAddr,(unsigned char*)temp,10);
		printf("temp[%d]=%s\r\n",i,temp);	
		kmy_EepromReadSequent(WriteAddr+10,(unsigned char*)(&dt),sizeof(dt));
		//printf("%d,%d,%d,%d,%d,%d\r\n",dt.year,dt.month,dt.date,dt.hour,dt.minite,dt.second);
		
		if(i<9)
		{
			strcat(temp,"  ");
		}
		else
		{
			strcat(temp," ");
		}
		sprintf(temp+strlen(temp),"%02d/%02d %02d:%02d",dt.date,dt.month,dt.hour,dt.minite);
		strcpy(OrdernumBuff[i],temp);
		if(offset==0)offset=DISPLAY_MAXORDERID;
		offset--;
	}
	return 0;
}


void Reprint_ConfirmOrder(const unsigned short Address)
{

	unsigned char orderdata[ORDRER_SIZE]={0};
	ORDER_STRUCT order[ORDER_LIMIT]={0};//one ORDER_STRUCT size 
	char CustomerComments[200]={0};
	char gOrderFood[2048]={0};
	char i;
	kmy_EepromReadSequent(Address+22,orderdata,sizeof(orderdata));
	//printf("index=%d,orderdata=%s\r\n",index,orderdata);
	for(i=0;i<20;i++)printf("%02x ",orderdata[i]);
	GetOneOrder((char*)orderdata,&order[0],gOrderFood,CustomerComments);
	PrintOrder(order,1,0,gOrderFood,CustomerComments);
}

void ReprintLastOrder(void)
{
	unsigned short Address=0;
	unsigned char total=0;
	
	kmy_EepromReadByte(TOTAL_CONFIRMADDR,&total);

	if(total==0)
	{

		kmy_LcdClear();
		DrawTitle_to_row(1,"No Last Order!");
		WaitkeyAndAutoExit(10);
		return;
	}
	if (total>2*DISPLAY_MAXORDERID)// if not initial store memory
	{
		clear_lcd();
		DrawTitle_to_row(1,"No Last Order");
		
		InitOrder();//reset the total number		
		WaitkeyAndAutoExit(10);
		return;
	}
	Address=(total-1)%DISPLAY_MAXORDERID;
	Address=CONFIRMORDER_BASE+Address*ORDRER_SIZE;

	Reprint_ConfirmOrder(Address);

}

char GetSelectOrder(char *src, char *des)
{
	char *p;
	
	p=src;
	p=strstr(p,"#");
	if(p!=NULL)
	{
		*des=*p;
		des++;
		p++;
		for(;*p!='#';p++,des++)
		{
			*des=*p;
		}
		*des=*p;
		des++;
		*des=0;
		return 0;
	}
	else
	{
		return 1;
	}
}


// if it's a comfirm order, store the order number to the CONFIRMORDER_BASE, and joint the order data from #..# 
// ORDER_BASE: CONFIRMORDER_BASE or REJECTORDER_BASE
// size is the orderdata length
char StoreAnOrder(unsigned short ORDER_BASE,unsigned char *orderID, unsigned char *date, unsigned char *orderdata,int size)
{
	unsigned char total=0;
	unsigned short writeaddr=0;
	//unsigned char testbuff[20]={0};
	int offset=0;
	
	
	kmy_EepromReadByte(ORDER_BASE-1,&total);
	printf("total_Confirm=%d\r\n",total);
	
	if(total>=2*DISPLAY_MAXORDERID)total=DISPLAY_MAXORDERID;//total loop from 0 to 2*DISPLAY_MAXORDERID


	//if(ORDER_BASE==CONFIRMORDER_BASE)
	//{
		offset=total%DISPLAY_MAXORDERID;
		writeaddr=ORDER_BASE+offset*ORDRER_SIZE;
	// one record: OrderID+ date time+order data
	//		 size:  10+12+less than 3K data
		kmy_EepromWrite(writeaddr,orderID,10);	// write order id length=10
		writeaddr +=10;
		kmy_EepromWrite(writeaddr,date,12); // struct date length=12
		writeaddr +=12;
		
		printf("writeaddr=%d\r\n",writeaddr);
		kmy_EepromWrite(writeaddr,orderdata,size);	// write order data from #..to ...#	
		kmy_EepromWriteByte(writeaddr+size+1,0);// write a /0 after the order #...#0
/*	}
	else
	{
		offset=total%DISPLAY_MAXORDERID;
		writeaddr=ORDER_BASE+offset*10;
		
		kmy_EepromWrite(writeaddr,orderID,10);
	}
	
	
	kmy_EepromReadSequent(writeaddr,testbuff,size);
	printf("readstore=%s\r\n",testbuff);
*/
	total++;
	if(total>=2*DISPLAY_MAXORDERID)total=DISPLAY_MAXORDERID;
	
	kmy_EepromWriteByte(ORDER_BASE-1,total);//store the total number
	return 0;
}



char InputDeliveryTime(unsigned char* buff)
{
	char retval=0;

	
	clear_lcd();
	
	retval = GetString_123TimeInput ("Input Delivery Time",SRF_123,SRF_123,buff,6,0);
	return retval;
}
char CheckTimeFormat(char* buff)
{
	int time=0; 
	char *p=NULL;
	if(strlen(buff)<1)
	{
		return 1;
	}
	p=buff;
	p=strstr(p,":");
	if(p==NULL)
	{
		return 1;
	}
	time=atoi(buff);//printf("time1=%d\r\n",time);
	if(time<0||time>=24)
	{
		return 1;
	}
	p++;
	time=atoi(p);//printf("time2=%d\r\n",time);
	if(time<0||time>=60)
	{
		return 1;
	}
	return 0;
}
char AcceptOrder_SpeedKey(ORDER_STRUCT *order, char* DeliveryTime)
{
	char buff[300]={0};
	unsigned char oneorderID[10]={0};
	unsigned char retval=0;
	char IP[26]={0};
	char Port[6]={0};

	char oneorder[3072]={0};

	
	struct
	{
		unsigned int year;
		unsigned char month;
		unsigned char date;
		unsigned char hour;
		unsigned char minite;
		unsigned char second;
	}dt;	

	kmy_EnableDisableTime3(0);// timer3 disable
	clear_lcd();
	DrawTitle_to_row(2,"Connecting...");

	if(strlen((char*)Domain)>0)
	{
		retval=tcp_Connect(Domain);
	}
	else
	{
		SeperateIpAndPort((char*)ServerIpPortBuf,IP,Port);	
		retval=tcp_Connect(ServerIpPortBuf);
	}
	
	if(retval!=TCP_OK)
	{	
		kmy_EnableDisableTime3(1);// timer3 enable
		clear_lcd();
		DrawTitle_to_row(2,"Accept Order Failed");	
		WaitkeyAndAutoExit (8);
		printf("tcp connect fail\r\n");
		return KEY_ReturnPrevious;
	}
	
	clear_lcd();
	DrawTitle_to_row(2,"Receiving...");
	
	
	GetHttpCallbackString(
						buff,
						(char*)CallbackURL, (char*)IP, (char*)Port,
						order->RestaurantID, (char*)LoginWebUsername,(char*)LoginWebPassword, 
						order->OrderNumber, "Accepted", "ok", DeliveryTime);

	printf("AcceptOrder=%s\r\n",buff);
	tcp_send((unsigned char*)buff,strlen(buff));
	
	memset(buff,0,sizeof(buff));
	tcp_receive((unsigned char*)buff,sizeof(buff),3,"OK");
	printf("buff=%s\r\n",buff);
	
	if(strstr(buff,"OK"))
	{		
		kmy_TimeGetTime(&dt.year,&dt.month,&dt.date,&dt.hour,&dt.minite,&dt.second,NULL);
		//printf("%d,%d,%d,%d,%d,%d\r\n",dt.year,dt.month,dt.date,dt.hour,dt.minite,dt.second);
		GetSelectOrderID(gOrderBuf,SelectOrderIndex,(char*)oneorderID);	
		GetSelectOrder(gOrderBuf,oneorder);
		//printf("oneorder=%s\r\n",oneorder);	
		StoreAnOrder(CONFIRMORDER_BASE,oneorderID,(unsigned char*)(&dt),(unsigned char*)oneorder,strlen(oneorder));
		//printf("Reject_orderID=%s\r\n",oneorderID);
		memset(gOrderBuf,0,sizeof(gOrderBuf));
		clear_lcd();
		DrawTitle_to_row(2,"Accept Order Success");
	}
	else
	{
		clear_lcd();
		DrawTitle_to_row(2,"Accept Order Failed");
	}
	
	kmy_EnableDisableTime3(1);// timer3 enable
	WaitkeyAndAutoExit (8);
	return KEY_ReturnInitInterface;
}

char AcceptOrder(ORDER_STRUCT *order)
{
	char buff[300]={0};
	unsigned char oneorderID[10]={0};
	unsigned char retval=0;
	char IP[26]={0};
	char Port[6]={0};
	char AcceptTimeNum=0;
	char AcceptTimeTable[10][MENU_COL]={0};
	char selectNum=0;

	char DeliveryTime[6]={0};
	char temp[MENU_COL]={0};
	char oneorder[3072]={0};
	char responsestr[30]={0};

	
	struct
	{
		unsigned int year;
		unsigned char month;
		unsigned char date;
		unsigned char hour;
		unsigned char minite;
		unsigned char second;
	}dt;	

	SeperateIpAndPort((char*)ServerIpPortBuf,IP,Port);
	
	kmy_EnableDisableTime3(0);// timer3 disable


	if(gCountDown==0)
	{
		if(strcmp((char*)AcceptTimeMode,"1")==0)
		{
			GetRejectReason(AcceptTimeTable,(char*)AcceptTimeOptions,&AcceptTimeNum);
			if(AcceptTimeNum==0)
			{
				clear_lcd();
				DrawTitle_to_row(2,"no reject reason");
				retval=WaitkeyAndAutoExit(10);
				selectNum=0;
				if(retval!=KEY_Enter)
				{
					return retval;
				}		
			}
			else
			{				
				retval=GetSelectItemOfMenus_SpeedAcceptKey(AcceptTimeTable,AcceptTimeNum,&selectNum);
				if(retval!=KEY_Enter)
				{
					return retval;
				}
			}
		
		}
		else
		{
			retval=InputDeliveryTime((unsigned char*)DeliveryTime);
		
		
			if(retval!=KEY_Enter)
			{
				return KEY_ReturnPrevious;	
			}
			if(CheckTimeFormat(DeliveryTime)==1)
			{
				clear_lcd();
				DrawTitle_to_row(2,"Time Format Error");	
				DrawTitle_to_row(3,"00:00");	
				WaitkeyAndAutoExit (8);
				printf("Time Format Error\r\n");
				return KEY_ReturnPrevious;
			}
		}
	}
	
	clear_lcd();
	memset(buff,0,sizeof(buff));
	strcpy(buff,"AT+QISTAT\r");
	send_at_cmd_and_receive((unsigned char*)buff,sizeof(buff),500,"CONNECT OK");
	printf("buff=%s\r\n",buff);
	if(strstr(buff,"CONNECT OK")==NULL)
	{
		DrawTitle_to_row(2,"Connecting...");
		retval=tcp_Connect(ServerIpPortBuf);
		if(retval!=TCP_OK)
		{	
			kmy_EnableDisableTime3(1);// timer3 enable
			clear_lcd();
			DrawTitle_to_row(2,"Accept Order Failed");	
			WaitkeyAndAutoExit (8);
			printf("tcp connect fail\r\n");
			return KEY_ReturnPrevious;
		}
	}
	memset(buff,0,sizeof(buff));

	clear_lcd();
	DrawTitle_to_row(2,"Receiving...");
	
	//"http://219.134.79.37:81/ibacstel/printer.php"

	if(gCountDown!=0)
	{
		strcpy(responsestr,(char*)AutoPrintString);
					my_string_replace((unsigned char*)responsestr,' ','_');//get rid of the space, use '_' instead,because http get can not accept space
					GetHttpCallbackString(
							buff,
							(char*)CallbackURL, (char*)IP, (char*)Port,
							order->RestaurantID, (char*)LoginWebUsername,(char*)LoginWebPassword, 
							order->OrderNumber, "Accepted", "ok", responsestr);
	}
	else
	{
		if(strcmp((char*)AcceptTimeMode,"1")==0)
		{
			strncpy(temp,AcceptTimeTable[selectNum],sizeof(temp)-1);
			my_string_replace((unsigned char*)temp,' ','_');//get rid of the space, use '_' instead,because http get can not accept space
			GetHttpCallbackString(
					buff,
					(char*)CallbackURL, (char*)IP, (char*)Port,
					order->RestaurantID, (char*)LoginWebUsername,(char*)LoginWebPassword, 
					order->OrderNumber, "Accepted", "ok", temp);
		
		}
		else
		{
			GetHttpCallbackString(
					buff,
					(char*)CallbackURL, (char*)IP, (char*)Port,
					order->RestaurantID, (char*)LoginWebUsername,(char*)LoginWebPassword, 
					order->OrderNumber, "Accepted", "ok", DeliveryTime);
		
		}
	}
	

	printf("AcceptOrder=%s\r\n",buff);
	tcp_send((unsigned char*)buff,strlen(buff));
	
	memset(buff,0,sizeof(buff));
	tcp_receive((unsigned char*)buff,sizeof(buff),3,"OK");
	printf("buff=%s\r\n",buff);
	
	if(strstr(buff,"OK"))
	{		
		kmy_TimeGetTime(&dt.year,&dt.month,&dt.date,&dt.hour,&dt.minite,&dt.second,NULL);
		GetSelectOrderID(gOrderBuf,SelectOrderIndex,(char*)oneorderID);	
		GetSelectOrder(gOrderBuf,oneorder);
		//printf("oneorder=%s\r\n",oneorder);	
		StoreAnOrder(CONFIRMORDER_BASE,oneorderID,(unsigned char*)(&dt),(unsigned char*)oneorder,strlen(oneorder));
		memset(gOrderBuf,0,sizeof(gOrderBuf));
		//DeleteOneOrder(gOrderBuf,SelectOrderIndex);	
		//	printf("deleteindex=%d,gOrderBuf=\r\n%s\r\n",SelectOrderIndex,gOrderBuf);
		clear_lcd();
		DrawTitle_to_row(2,"Accept Order Success");
	}
	else
	{
		clear_lcd();
		DrawTitle_to_row(2,"Accept Order Failed");
	}
	
	kmy_EnableDisableTime3(1);// timer3 enable
	WaitkeyAndAutoExit (8);
	return KEY_ReturnInitInterface;
}

void GetRejectReason(char (*ReasonTable)[MENU_COL], char *Reason, char *RejectNum )
{
	int i=0;
	int len=0;
	char count=0;
	char *p;
	char *pt;

	len=strlen(Reason);
	if(len==0)return;
	
	for(i=0;i<len;i++)
	{
		if(Reason[i]==';')count++;
	}
	if(count==0)
	{
		strncpy(ReasonTable[0],Reason,20);
		*RejectNum=1;
		return;
	}
	p=Reason;
	if(count>15)count=15;
	for(i=0;i<count;i++)
	{
		pt=strstr(p,";");
		if(pt-p>20)
		{
			strncpy(ReasonTable[i],p,20);
		}
		else
		{
			strncpy(ReasonTable[i],p,pt-p);
		}
		pt++;
		p=pt;
		*RejectNum=count;
	}	
}
char RejectOrder(ORDER_STRUCT *order)
{
	char buff[300]={0};
	unsigned char oneorderID[10]={0};
	unsigned char retval=0;
	char RejectReasonTable[15][MENU_COL]={0};
	char rejectNum=0;
	char selectNum=0;
	char IP[26]={0};
	char Port[6]={0};
	char Time[8]={0};
	unsigned char hour=0;
	unsigned char min=0;
	char temp[MENU_COL]={0};	
	char oneorder[3072]={0};
	struct
	{
		unsigned int year;
		unsigned char month;
		unsigned char date;
		unsigned char hour;
		unsigned char minite;
		unsigned char second;
	}dt;	
	
	SeperateIpAndPort((char*)ServerIpPortBuf,IP,Port);
	kmy_TimeGetTime(NULL,NULL,NULL,&hour,&min,NULL,NULL);
	sprintf(Time,"%02d:%02d",hour,min);
	GetRejectReason(RejectReasonTable,(char*)RejectReason,&rejectNum);
	printf("RejectReason=%s,rejectNum=%d\r\n",RejectReason,rejectNum);

	if(rejectNum==0)
	{
		clear_lcd();
		DrawTitle_to_row(2,"no rejectreason");
		retval=WaitkeyAndAutoExit(10);
		selectNum=0;
		if(retval!=KEY_Enter)
		{
			return retval;
		}		
	}
	else
	{
		retval=GetSelectItemOfMenus(RejectReasonTable,rejectNum,&selectNum);
		if(retval!=KEY_Enter)
		{
			return retval;
		}
	}
	

	kmy_EnableDisableTime3(0);// timer3 disable
	

	clear_lcd();
	memset(buff,0,sizeof(buff));
	strcpy(buff,"AT+QISTAT\r");
	send_at_cmd_and_receive((unsigned char*)buff,sizeof(buff),500,"CONNECT OK");
	printf("buff=%s\r\n",buff);
	if(strstr(buff,"CONNECT OK")==NULL)
	{
		DrawTitle_to_row(2,"Connecting...");
		retval=tcp_Connect(ServerIpPortBuf);
		if(retval!=TCP_OK)
		{
			
			kmy_EnableDisableTime3(1);// timer3 enable
			clear_lcd();
			DrawTitle_to_row(2,"Reject Order Failed");		
			WaitkeyAndAutoExit (10);	
			printf("tcp connect fail\r\n");
			return KEY_ReturnPrevious;
		}

	}
	memset(buff,0,sizeof(buff));
	clear_lcd();
	DrawTitle_to_row(2,"Receiving...");
	
	strncpy(temp,RejectReasonTable[selectNum],sizeof(temp)-1);
	my_string_replace((unsigned char*)temp,' ','_');//get rid of the space, use '_' instead, because http get can not accept space
	//"http://219.134.79.37:81/ibacstel/printer.php"
	GetHttpCallbackString(
		buff,
		(char*)CallbackURL, (char*)IP, (char*)Port,
		order->RestaurantID, (char*)LoginWebUsername, (char*)LoginWebPassword, 
		order->OrderNumber, "Rejected", temp, Time);

	printf("RejectOrder=%s\r\n",buff);
	tcp_send((unsigned char*)buff,strlen(buff));
	
	memset(buff,0,sizeof(buff));
	tcp_receive((unsigned char*)buff,sizeof(buff),3,"OK");
	
	if(strstr(buff,"OK"))
	{
		kmy_TimeGetTime(&dt.year,&dt.month,&dt.date,&dt.hour,&dt.minite,&dt.second,NULL);
		GetSelectOrderID(gOrderBuf,SelectOrderIndex,(char*)oneorderID);
		GetSelectOrder(gOrderBuf,oneorder);
		StoreAnOrder(CONFIRMORDER_BASE,oneorderID,(unsigned char*)(&dt),(unsigned char*)oneorder,strlen(oneorder));
		memset(gOrderBuf,0,sizeof(gOrderBuf));
		clear_lcd();
		DrawTitle_to_row(2,"Reject Order Success");
	}
	else
	{
		clear_lcd();
		DrawTitle_to_row(2,"Reject Order Failed");
	}
	
	kmy_EnableDisableTime3(1);// timer3 enable
	WaitkeyAndAutoExit (10);	
	return KEY_ReturnInitInterface;
}



char AcceptRejectMenu(ORDER_STRUCT *order)
{

	const static struct MenuFuc_Orders Menu[2] =
	{
		{"1.AcceptOrder", "1.AcceptOrder", AcceptOrder},
		{"2.RejectOrder", "2.RejectOrder", RejectOrder}
	} ;
	struct MenuOperate_Orders MenuOp =
	{
		(struct MenuFuc_Orders*) Menu,
		2,
		0,
		0,
		0,
		MaxRowOneScr,
		1,
		0,
		0,
	};

	while (1)
	{
		MenuHandler_Orders(&MenuOp);

		if (MenuOp.RetVal == KEY_Enter)
		{
			MenuOp.FucRetVal = MenuOp.Menu->MenuFuc (order);

			if (MenuOp.FucRetVal == KEY_WaitTimeout || MenuOp.FucRetVal == KEY_ReturnInitInterface )
			{
				CurProc = CurProc_Return;
				return MenuOp.FucRetVal;
			}
			else
			{
				kmy_LcdClear();
				MenuOp.flashflag = 1;
			}
		}
		else
		{
			InitFlag = 1;
			CurProc = CurProc_Return;
			return MenuOp.RetVal;
		}
	}
	
}

void InitOrder(void)
{
	kmy_EepromWriteByte(TOTAL_CONFIRMADDR,0);
//	kmy_EepromWriteByte(TOTAL_REJECTADDR,0);
	printf("Inint eeprom order base...\r\n");
}

char AutoPrintOrder(void)
{
	char *p1 = NULL;
	ORDER_STRUCT order[ORDER_LIMIT]={0};//one ORDER_STRUCT size 
	char retval=0;
	char ret=0;
	char temp_ONOFF=0;
	char gOrderFood[2048]={0};
	char CustomerComments[200]={0};	
	char DeliveryTime[10]={0};

	if(strstr((char*)gOrderBuf,"Content-Length: 0")!=NULL)return 0;
		
	if(GetCountOfOrders(gOrderBuf)==0)
	{
		printf("Not a full orderdata, receive again\r\n");
		return 0;
	}

	p1 = gOrderBuf;
	
	memset(gOrderFood,0,sizeof(gOrderFood));
	memset(CustomerComments,0,sizeof(CustomerComments));
	GetOneOrder(p1,&order[0],gOrderFood,CustomerComments);

	temp_ONOFF=GPRS_ONOFF;
	GPRS_ONOFF=1;//close check order

	//AddCarriage(gOrderFood,32);
	retval=PrintOrder(order,0,0,gOrderFood,CustomerComments);

	if(gCountDown!=0)// auto print and accept
	{
		if(retval==Printer_OK)
		{
			AcceptOrder(&order[0]);
		}
	}
	else
	{
		if(retval==Printer_OK)
		{
			ret=HaveReceiveOrder(0);
			if(ret==KEY_Enter)
			{
				AcceptRejectMenu(&order[0]);
			}
			else
			{
				switch(ret)
				{
					case KEY1:
						strcpy(DeliveryTime,"10minutes");
						break;
					case KEY2:
						strcpy(DeliveryTime,"20minutes");
						break;
					case KEY3:
						strcpy(DeliveryTime,"30minutes");
						break;
					case KEY4:
						strcpy(DeliveryTime,"40minutes");
						break;
					case KEY5:
						strcpy(DeliveryTime,"50minutes");
						break;
					case KEY6:
						strcpy(DeliveryTime,"60minutes");
						break;
					case KEY7:
						strcpy(DeliveryTime,"70minutes");
						break;
					case KEY8:
						strcpy(DeliveryTime,"80minutes");
						break;
					case KEY9:
						strcpy(DeliveryTime,"90minutes");
						break;
					default:break;
				}
				AcceptOrder_SpeedKey(&order[0],DeliveryTime);
			}
		}

	}
	
	if(temp_ONOFF==0)GPRS_ONOFF=0;//if  previous state is open then open check order
	ReceiveOrderFlag=0;
	return 0;
}

char Latest_Orders (char *msg)
{
	//char keyval=0;
	char *p1 = NULL;
	char *p2 = NULL;
	unsigned char num=0;
	char i=0;
	ORDER_STRUCT order[ORDER_LIMIT]={0};//one ORDER_STRUCT size 
	char retval=0;
	char index=0;
	char temp_ONOFF=0;
	char gOrderFood[2048]={0};
	char CustomerComments[200]={0};

/*

// debug-----
static char test_num=0;
char testtmp[3]={0};
sprintf(testtmp,"%d",test_num);
test_num++;
strcpy(gOrderBuf,"#1004*1*1110");
strcat(gOrderBuf,testtmp);
strcat(gOrderBuf,"*TEST");
strcat(gOrderBuf,testtmp);
strcat(gOrderBuf," VEGETARIAN PIZZA,2,Vego Medium,36.00; ,1,Vego Large,22.00; ,1,Tamarama Medium,18.00; ,1,Tamarama Large,22.00*.00;0;;98.00;*4;Nathan Airey(NOTPAID) - 0401161197; dfg, dfg, HIGHLANDS, VIC, 3660;ASAPplease! 18-12-12; 0;7;;0401161197 ;*#");
	Writting_gOrderBuf=0;
// -------
*/
	WaitKeyRelease();

	if(GPRS_ONOFF==1)
	{
		clear_lcd();
		DrawTitle_to_row(1,"GPRS is not open yet");
		DrawTitle_to_row(2,"please check the open ");		
		DrawTitle_to_row(3,"and close time");
		WaitkeyAndAutoExit(10);
		return KEY_ReturnPrevious;
	}	

LIST_AGAIN:	
	if(writeto_gOrderBuf==1)
	{
		clear_lcd();
		DrawTitle_to_row(2,"Please wait...");
		while(1)
		{
			if(Writting_gOrderBuf==0)break;
		}
	}
	p1=strstr((char*)gOrderBuf,"Content-Length: 0");
	if(p1!=NULL)
	{
		clear_lcd();
		DrawTitle_to_row(1,"No order");
		
		WaitkeyAndAutoExit(10);
		return KEY_ReturnPrevious;

	}
	
	num=GetCountOfOrders((char*)gOrderBuf);
	printf("num=%d\r\n",num);

	if(num==0)
	{
		clear_lcd();
		DrawTitle_to_row(1,"No order");
		
		WaitkeyAndAutoExit(10);
		return KEY_ReturnPrevious;

	}

	p1 = gOrderBuf;
	if(num>ORDER_LIMIT)num=ORDER_LIMIT;//limit 10 mun orders
	memset(gOrderFood,0,sizeof(gOrderFood));
	memset(CustomerComments,0,sizeof(CustomerComments));
	for(i=0; i<num; i++)
	{
		p2 = GetOneOrder(p1,&order[i],gOrderFood,CustomerComments);

		if(p2 == NULL)
		break;

		p1 = p2;
	}

	temp_ONOFF=GPRS_ONOFF;
	GPRS_ONOFF=1;//close check order
	retval=DisplayOrder(num,order,&index,gOrderFood,CustomerComments);
	if(temp_ONOFF==0)GPRS_ONOFF=0;//if  previous state is open then open check order
	SelectOrderIndex=index+1;
	printf("SelectOrderIndex=%d\r\n",SelectOrderIndex);
	if(retval==KEY_Enter)
	{
		retval=AcceptRejectMenu(&order[index]);
		goto LIST_AGAIN;
	}
	
	return KEY_ReturnPrevious;
}

/*

char Reject_Orders (char *msg)
{	
	unsigned char total=0;
	char index=0;
	char OrdernumBuff[DISPLAY_MAXORDERID][MENU_COL]={0};
	char retval=0;
	char ret=0;
	
	
	WaitKeyRelease();
	
	if(ReadOutOrders(REJECTORDER_BASE,OrdernumBuff)==1)
	{
		return KEY_ReturnPrevious;
	}
	
	kmy_EepromReadByte(TOTAL_REJECTADDR,&total);
	retval=GetSelectItemOfMenus(OrdernumBuff,total,&index); 
	if(retval==KEY_Enter)
	{
		WaitKeyRelease();
		clear_lcd();
		text_out_to_row(0,"1.Delete orders");
		DispHighLightRow(0);
		ret=WaitkeyAndAutoExit(10);
		if(ret==KEY_Enter)
		{
			WaitKeyRelease();
			
			kmy_EepromWriteByte(TOTAL_REJECTADDR,0);
			
			clear_lcd();
			DrawTitle_to_row(1,"Delete success");			
			return WaitkeyAndAutoExit(3);
		}
		
	}
	
	return retval;
}
*/
char Confirm_Orders (char *msg)
{	
	unsigned char total=0;
	char index=0;
	char OrdernumBuff[DISPLAY_MAXORDERID][MENU_COL]={0};
	char retval=0;
	char ret=0;
	unsigned char display_total=0;
	unsigned short AddressList[DISPLAY_MAXORDERID]={0};
	
	WaitKeyRelease();
	
	if(ReadOutOrders(CONFIRMORDER_BASE,OrdernumBuff,AddressList)==1)
	{
		return KEY_ReturnPrevious;
	}

	kmy_EepromReadByte(TOTAL_CONFIRMADDR,&total);
	display_total=total;
	if(total>DISPLAY_MAXORDERID)display_total=DISPLAY_MAXORDERID;
	retval=GetSelectItemOfMenus(OrdernumBuff,display_total,&index);// first item index=0;
	printf("select index=%d\r\n",index);
	if(retval==KEY_DEL)
	{	
		WaitKeyRelease();
		clear_lcd();
		text_out_to_row(0,"1.Delete orders");
		DispHighLightRow(0);
		ret=WaitkeyAndAutoExit(10);
		if(ret==KEY_Enter)
		{	
			WaitKeyRelease();
			
			kmy_EepromWriteByte(TOTAL_CONFIRMADDR,0);
			clear_lcd();
			DrawTitle_to_row(1,"Delete success");			
			return WaitkeyAndAutoExit(3);
		}
		
	}
	else if(retval==KEY_Enter)
	{
		clear_lcd();
		printf("address=%d\r\n",AddressList[index]);
		Reprint_ConfirmOrder(AddressList[index]);
	}
		
 	return retval;
}
char gprs_GetTcpConnectATString(char *dest)//reserve for fix next time
{
	char IP[26]={0};
	char Port[6]={0};
	char *p;

	memset(IP,0,sizeof(IP));	
	memset(Port,0,sizeof(Port));
	strcpy ( (char *) dest , AT_TcpConnect );
	if(strlen((char*)Domain)>0)// domain priority
	{
		p=strstr((char*)Domain,":");
		if(p!=NULL)
		{
			strncat((char *) dest,(char*)Domain,p-(char*)Domain);
			strncpy(Port,p+1,sizeof(Port)-1);
		}
		else
		{
			strcat((char *) dest, (char*)Domain);
		}
	}
	else
	{
		SeperateIpAndPort((char*)ServerIpPortBuf,IP,Port);
		strcat((char *) dest, IP);
	}
	strcat ( (char *) dest , "\",\"" );
	strcat ( (char *) dest , (char const*)Port);
	strcat ( (char *) dest , "\"\r" );
	return 0;
}

// get version name and set the UpgradeFlag
 char StoreVersion(char *VersionName)
{
	char temp[200]={0};
	char *p=NULL;
	char *pt=NULL;
	unsigned char n=0;
	unsigned char i=0;

	// find the last /, and strcat main_ver0.1.bin		
	n=strlen((char*)UpgradeURL);
	pt=p=(char*)UpgradeURL;
	for(i=0;i<n;i++)
	{
		if(*p=='/')pt=p; // pt-> the last /
		p++;
	}	
	strncpy(temp,(char*)UpgradeURL,pt-(char*)UpgradeURL+1);

	p=VersionName;
	p=strstr(p,"main");
	if(p==NULL)return 1;
	pt=p;
	pt=strstr(pt,".bin");	
	if(pt==NULL)return 1;
	pt=pt+strlen(".bin");// p-> main_ver0.1.bin<-pt
	n=pt-p;printf("n=%d\r\n",n);
	
	if(n>0&&n<20)
	{
		strncat((char*)temp,p,n);
		memset(UpgradeURL,0,sizeof(UpgradeURL));
		strcpy((char*)UpgradeURL,(char*)temp);printf("UpgradeURL=%s\r\n",UpgradeURL);
		UpgradeFlag[0]='1';
		StorageVariable();
		return 0;
	}
	else 
	{
		return 1;
	}

	
}
void GPRS_Thread(void)//10ms
{
	#define AUTOCHECK_WAIT 0
	#define AUTOCHECK_ATE 1
	#define AUTOCHECK_CONNECT 2
	#define AUTOCHECK_CONNECT_OK 3
	#define AUTOCHECK_SEND 4
	#define AUTOCHECK_CHECK_SEND_CHAR 5
	#define AUTOCHECK_SENDDATAS 6
	#define AUTOCHECK_SEND_OK 7
	#define AUTOCHECK_RECV 8
	#define AUTOCHECK_PROCESSING 9
	#define AUTOCHECK_EXIT 10
	
	unsigned int SendLen = 0;
	char LengthBuff[6] = {0};

	
	static unsigned char AutoCheckState = 0;
	static uint16_t AutoCheckInterval = 0;
	static uint16_t AutoCheckTimeout = 0;


	static unsigned char CheckVersionFlag=0;

	char IP[26]={0};
	char Port[6]={0};

	
	if(DebugLock==1)return;
	if(GPRS_ONOFF==1)return;//GRPS is OFF
	switch(AutoCheckState)
	{
		case AUTOCHECK_WAIT:	
			check_Interval=atoi((char*)CheckOrderInterval);
			if(check_Interval<=0)check_Interval=10;//10ms*1000=10s
			if(AutoCheckInterval++ > (100*check_Interval))
			{
				AutoCheckInterval = 0;
				AutoCheckState++;//To next state
				ATsendreceive_Lock=1;//GPRS_Thread occupy the USART2
				printf("AUTOCHECK_WAIT=%d\r\n",check_Interval);
				
				kmy_USART2ReceiveReset();
				kmy_USART2SendString(AT_TcpStatus);
			}
			else
			{
				ATsendreceive_Lock=0;
			}
			break;
		case AUTOCHECK_ATE:
			kmy_USART2ShowBuff();
			if(kmy_USART2CheckBuff("CONNECT OK"))
			{
				AutoCheckState=AUTOCHECK_SEND;
			}
			else if(kmy_USART2CheckBuff("IP INITIAL")||kmy_USART2CheckBuff("IP CLOSE"))
			{
				kmy_USART2SendString(AT_ATE0);
				kmy_USART2SendString(AT_TcpHeadOff);
				if(strlen((char*)Domain)>0)// domain priority
				{
					kmy_USART2SendString(AT_DNSconnect);
				}
				else
				{
					kmy_USART2SendString(AT_IPconnect);
				}
				AutoCheckState++;//To next state
			}
			else
			{
				kmy_USART2SendString(AT_TcpClose2);
				
				AutoCheckState=AUTOCHECK_EXIT+1;
			}
			
			AutoCheckTimeout = 0;
			kmy_USART2ReceiveReset();
			printf("AUTOCHECK_ATE\r\n");
			break;
		case AUTOCHECK_CONNECT:
			if(AutoCheckTimeout++ > 5)
			{
				kmy_USART2ShowBuff();
				gprs_GetTcpConnectATString(pBufNonBlock);
				kmy_USART2ReceiveReset();
				kmy_USART2SendString((unsigned char*)pBufNonBlock);
				
				AutoCheckState++;//To next state
				
				printf("send->%s\r\n",pBufNonBlock);
				AutoCheckTimeout = 0;
			}
			break;
		case AUTOCHECK_CONNECT_OK:
			if(kmy_USART2CheckBuff("CONNECT OK"))
			{
				AutoCheckState++;//To next state
				printf("CONNECT OK\r\n");
				AutoCheckTimeout = 0;
			}
			else if(kmy_USART2CheckBuff("CONNECT FAIL"))
			{
				
				kmy_USART2ShowBuff();
				kmy_USART2SendString(AT_TcpClose2);
				printf("Connect Status: CONNECT FAIL\r\n");			
				AutoCheckState = AUTOCHECK_EXIT;				
						
			}
			else if(kmy_USART2CheckBuff("ALREADY CONNECT"))
			{
				printf("Connect Status: ALREADY CONNECT\r\n");
				AutoCheckTimeout = 0;
				AutoCheckState++;//To next state
			}
			else if(kmy_USART2CheckBuff("PDP DEACT"))
			{
				kmy_USART2SendString(AT_TcpClose2);
				printf("Connect Status: PDP DEACT\r\n");
				AutoCheckState = AUTOCHECK_EXIT;			
			}
			else if(kmy_USART2CheckBuff("ERROR"))
			{
				kmy_USART2SendString(AT_TcpClose2);
				kmy_USART2ShowBuff();
				
				printf("Connect Status: ERROR\r\n");				
				AutoCheckState = AUTOCHECK_EXIT;				
					
			}
			if(AutoCheckTimeout++ > AUTOCHECK_TIMEOUT)
			{
				AutoCheckTimeout = 0;
				AutoCheckState = AUTOCHECK_EXIT;				
			}
			break;
		case AUTOCHECK_SEND:// send length
			memset (pBufNonBlock, 0, sizeof (pBufNonBlock) );
			SeperateIpAndPort((char*)ServerIpPortBuf,IP,Port);
			
			if(CheckVersionFlag==0)
			{
				HttpGET_VersionString(pBufNonBlock,(char*)VersionURL, (char*)ResID,VersionString,(char*)IP,(char*)Port);
			}
			else
			{
				GetHttpGETString(pBufNonBlock,(char*)RequestWebURL, (char*)ResID, (char*)LoginWebUsername, (char*)LoginWebPassword, (char*)IP,(char*)Port);
			}	
			
			SendLen = strlen((const char *)pBufNonBlock);
			sprintf(LengthBuff,"%d",SendLen);
			
			memset (pBufNonBlock, 0, sizeof (pBufNonBlock) );			
			strcpy ( pBufNonBlock, AT_TcpSend); 		
			strcat ( pBufNonBlock, (char const *) LengthBuff);
			strcat ( pBufNonBlock, "\r");
			
			kmy_USART2ReceiveReset();
			kmy_USART2SendString((unsigned char*)pBufNonBlock);
			printf("send->%s\r\n",pBufNonBlock);
			AutoCheckState++;//To next state
			
			AutoCheckTimeout = 0;

		
			break;
		case AUTOCHECK_CHECK_SEND_CHAR://wait ">"
			if(kmy_USART2CheckBuff(">"))
			{
				printf(">\r\n");
				AutoCheckState++;//To next state
				AutoCheckTimeout = 0;
				kmy_USART2ReceiveReset();					
			}
			else if(kmy_USART2CheckBuff("ERROR"))
			{
				printf("Send Status, Check '>': ERROR\r\n");
				AutoCheckState = AUTOCHECK_EXIT;
			}
			/* Timeout Handling */
			if(AutoCheckTimeout++ >  800)//8s
			{
				AutoCheckTimeout = 0;
				AutoCheckState = AUTOCHECK_EXIT;
				printf("Check '>' timeout\r\n");
			}
			break;
		case AUTOCHECK_SENDDATAS:
			memset (pBufNonBlock, 0, sizeof (pBufNonBlock) );
			SeperateIpAndPort((char*)ServerIpPortBuf,IP,Port);

			if(CheckVersionFlag==0)
			{
				HttpGET_VersionString(pBufNonBlock,(char*)VersionURL, (char*)ResID,VersionString,(char*)IP,(char*)Port);
			}
			else
			{
				GetHttpGETString(pBufNonBlock,(char*)RequestWebURL, (char*)ResID, (char*)LoginWebUsername, (char*)LoginWebPassword, (char*)IP,(char*)Port);
			}	
			

			kmy_USART2ReceiveReset();					
			kmy_USART2SendString((unsigned char*)pBufNonBlock);
			
			AutoCheckState++;//To next state
			
			AutoCheckTimeout = 0;
			printf("send->%s\r\n",pBufNonBlock);
			break;
		case AUTOCHECK_SEND_OK:
			if(kmy_USART2CheckBuff("SEND OK"))
			{
				printf("get->SEND OK\r\n");
				AutoCheckState++;//To next state
				
				AutoCheckTimeout = 0;
			}
			else if(kmy_USART2CheckBuff("SEND FAIL"))
			{
				printf("Send Status: SEND FAIL\r\n");
				AutoCheckState = AUTOCHECK_EXIT;
			}
			else if(kmy_USART2CheckBuff("ERROR"))
			{
				printf("Send Status: ERROR\r\n");
				AutoCheckState = AUTOCHECK_EXIT;
			}
			/* Timeout Handling */
			if(AutoCheckTimeout++ > AUTOCHECK_TIMEOUT)
			{
				AutoCheckTimeout = 0;
				AutoCheckState = AUTOCHECK_EXIT;
			}
			break;
		case AUTOCHECK_RECV:
			
			if(AutoCheckTimeout++ > AUTOCHECK_TIMEOUT)//60 seconds time out
			{
				AutoCheckTimeout = 0;
				AutoCheckState = AUTOCHECK_EXIT;
				printf("AUTOCHECK_RECV time out\r\n");
			}
			
			if(kmy_USART2CheckBuff("200 OK"))//HTTP/1.1 200 OK or HTTP/1.0 200 OK
			{
				connectfail_conunt=0;
				AutoCheckTimeout = 0;
				AutoCheckState = AUTOCHECK_PROCESSING;
			}
			else if(kmy_USART2CheckBuff("404 Not Found"))// HTTP/1.1 or HTTP/1.0 Not Found
			{
				kmy_USART2ReceiveReset();					
				AutoCheckTimeout = 0;
				AutoCheckState = AUTOCHECK_EXIT;
				
				printf("HTTP/1.1 404 Not Found\r\n");
			}
			else if (kmy_USART2CheckBuff("204 No Content"))//specially for Australia project, when no order respose HTTP/1.1  No Content
			{
				kmy_USART2ShowBuff();
				kmy_USART2ReceiveReset();					
				AutoCheckTimeout = 0;
				AutoCheckState=AUTOCHECK_EXIT+1;//To next state default
				connectfail_conunt=0;
			}
			break;
		case AUTOCHECK_PROCESSING:
			
			if(AutoCheckTimeout++>400)
			{
				kmy_USART2ShowBuff();
			
			
				if(CheckVersionFlag==0)// version data
				{	
					memset(gOrderBuf,0,sizeof(gOrderBuf));
					SendLen=kmy_USART2ReadToEnd(gOrderBuf,sizeof(gOrderBuf));// read out the usart2 buffer to gOrderBuf
					if(strstr(gOrderBuf,"main_"))
					{
						if(StoreVersion(gOrderBuf)==0)
						{
							printf("UpgradeFlag=%s\r\nreset pos\r\n",UpgradeFlag);
							NVIC_SystemReset();
							//WaitkeyAndAutoExit (10);
						}
					}
					
					memset(gOrderBuf,0,sizeof(gOrderBuf));
					kmy_USART2ReceiveReset();	
					AutoCheckTimeout = 0;
					AutoCheckState = AUTOCHECK_CONNECT;
					CheckVersionFlag=1;
				}
				else // order data
				{					
					AutoCheckState=AUTOCHECK_EXIT+1;//To next state default					
					AutoCheckTimeout = 0;
					writeto_gOrderBuf=1;
					memset(gOrderBuf,0,sizeof(gOrderBuf));
					SendLen=kmy_USART2ReadToEnd(gOrderBuf,sizeof(gOrderBuf));// read out the order data to gOrderBuf
					printf("reclen=%d\r\n",SendLen);
					if(SendLen>260&&strstr(gOrderBuf,"#")!=NULL)
					{
						ReceiveOrderFlag=1;
						printf("have order\r\n");
					}
					else
					{
						ReceiveOrderFlag=0;
					}
					//printf("gOrderBuf=%c %c %c %c %c\r\n",gOrderBuf[0],gOrderBuf[1],gOrderBuf[2],gOrderBuf[3],gOrderBuf[4]);
					writeto_gOrderBuf=0;
					
					connectfail_conunt=0;
			
				}								
			}	
			break;
		case AUTOCHECK_EXIT:
					
			kmy_USART2ReceiveReset();					
			ATsendreceive_Lock=0;
			AutoCheckState = AUTOCHECK_WAIT;
			AutoCheckInterval = 0;
			AutoCheckTimeout = 0;
			printf("END:AUTOCHECK_EXIT\r\n");
			kmy_LedDataLedOff();

					
			kmy_USART2SendString(AT_TcpClose1);
			kmy_USART2SendString(AT_TcpClose2);
			
			connectfail_conunt++;
			break;
		default:
			ATsendreceive_Lock=0;
			AutoCheckState = AUTOCHECK_WAIT;
			AutoCheckInterval = 0;
			AutoCheckTimeout = 0;
			printf("END:Normal\r\n");
			kmy_LedDataLedOff();
			break;
	}

}





// flag=1, just check if have receive an order
// flag=0, beep and lcd flash
// if BeepDuration=0, no beep
// if BeepDuration=1, beep until press a key 
unsigned char HaveReceiveOrder(char flag)
{
	int t=0;
	unsigned char keyval=0;
	char i=8;
	int j=0;

	
	if(ReceiveOrderFlag==1)
	{
		if(flag==1)return KEY_Enter;
		ReceiveOrderFlag=0;
		
		t=atoi((char*)BeepDuration);
		if(t==2)i=10;
		//printf("BeepDuration=%d\r\n",t);		
		LcdBlackLightFlash=1;
		clear_lcd();
		DrawTitle_to_row(1,"You have an order");
		DrawTitle_to_row(2,"Press speed key to ");
		DrawTitle_to_row(3,"accept or press OK to proceed");
		DrawTitle_to_row(4,"proceed");
		kmy_AutoPostKey(0);
		while(1)
		{
			switch(t)
			{
				case 0:
					break;
				case 1:
					if(i>0)
					{
						BeepLound();
						i--;
					}
					else
					{
						j++;
						if(j==200)
						{
							j=0;
							i=8;
						}
					}
					msleep(50);
					break;
				default:
					if(i>0)
					{
						BeepLound();
						msleep(50);
						i--;
					}
					break;
			}
			keyval = GetKeyValue();
			
			if (keyval == KEY_NONE) continue;
			switch(keyval)
			{
				case KEY1:
				case KEY2:
				case KEY3:
				case KEY4:
				case KEY5:
				case KEY6:
				case KEY7:
				case KEY8:
				case KEY9:
					LcdBlackLightFlash=0;
					return keyval;
				case KEY_Enter:
				case KEY_ReturnInitInterface:
				case KEY_ReturnPrevious:
				case KEY_WaitTimeout:
					LcdBlackLightFlash=0;
					return KEY_Enter;
				default:break;					
			}
		}
	}
	return 0;
}


char CheckOrderFailWarn(void)
{
	if(connectfail_conunt>=4)
	{
		connectfail_conunt=0;
		clear_lcd();
		NVIC_SystemReset();
		return WaitkeyAndAutoExit(120); 
	}
	return 0;
}





